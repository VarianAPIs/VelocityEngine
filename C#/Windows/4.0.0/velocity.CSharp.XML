<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Velocity.CSharp</name>
    </assembly>
    <members>
        <member name="T:BaseImageBasedRegistrationSettingsStructure">
             <summary>Common settings for image-based registrations.  
            
            Attributes
            ----------
            * `roiStart` : `vsc::VectorR3d`  
                The region of interest starting point. Defines a cuboid together with
                roiEnd.  
            
            * `roiEnd` : `vsc::VectorR3d`  
                The region of interest ending point. Defines a cuboid together with
                roiStart.  
            
            * `primaryStartLevel` : `double`  
            
            * `primaryEndLevel` : `double`  
            
            * `secondaryStartLevel` : `double`  
            
            * `secondaryEndLevel` : `double`  
            
            * `preprocessingMethod` : `PreprocessingFilterMethod`  
                Optional image pre-processing filter to use before the main registration
                algorithm.  
            
             </summary>
        </member>
        <member name="M:BaseImageBasedRegistrationSettingsStructure.#ctor">
            <summary>
            </summary>
        </member>
        <member name="T:BaseRegistrationSettingsStructure">
             <summary>
            Attributes
            ----------
            * `scriptingTextUofM` : `std::string`  
            
             </summary>
        </member>
        <member name="M:BaseRegistrationSettingsStructure.#ctor">
            <summary>
            </summary>
        </member>
        <member name="T:BoolList.BoolListEnumerator">
            Note that the IEnumerator documentation requires an InvalidOperationException to be thrown
            whenever the collection is modified. This has been done for changes in the size of the
            collection but not when one of the elements of the collection is modified as it is a bit
            tricky to detect unmanaged code that modifies the collection under our feet.
        </member>
        <member name="T:BSplineDeformableRegistrationSettingsStructure">
             <summary>Settings for running a deformable registration.  
            
            Attributes
            ----------
            * `numberOfMultiResolutionLevels` : `int`  
                The number of resolution levels. All other settings must be the same size as
                specified here. Each i'th entry in the individual settings lists is used for
                the i'th resolution pass.  
            
            * `applyBoundaryContinuityConstraints` : `std::vector&lt; bool &gt;`  
            
            * `applyTopologicalRegularizer` : `std::vector&lt; bool &gt;`  
            
            * `topologicalRegularizerDistanceLimitingCoefficient` : `std::vector&lt; VectorR3d &gt;`  
            
            * `numberOfHistogramBins` : `std::vector&lt; int &gt;`  
            
            * `samplesDenominator` : `std::vector&lt; int &gt;`  
            
            * `maximumNumberOfIterations` : `std::vector&lt; int &gt;`  
            
            * `maximumNumberOfConsecutiveOptimizerAttempts` : `std::vector&lt; int &gt;`  
            
            * `metricValuePercentageDifference` : `std::vector&lt; double &gt;`  
            
            * `maximumStepLength` : `std::vector&lt; double &gt;`  
            
            * `minimumStepLength` : `std::vector&lt; double &gt;`  
            
            * `relaxationFactor` : `std::vector&lt; double &gt;`  
            
            * `gradientMagnitudeTolerance` : `std::vector&lt; double &gt;`  
            
            * `gridCellSize` : `std::vector&lt; VectorR3d &gt;`  
            
            * `gridCellSizeType` : `std::vector&lt; char &gt;`  
            
             </summary>
        </member>
        <member name="M:BSplineDeformableRegistrationSettingsStructure.#ctor">
            <summary>
            </summary>
        </member>
        <member name="T:CharList.CharListEnumerator">
            Note that the IEnumerator documentation requires an InvalidOperationException to be thrown
            whenever the collection is modified. This has been done for changes in the size of the
            collection but not when one of the elements of the collection is modified as it is a bit
            tricky to detect unmanaged code that modifies the collection under our feet.
        </member>
        <member name="T:DoubleList.DoubleListEnumerator">
            Note that the IEnumerator documentation requires an InvalidOperationException to be thrown
            whenever the collection is modified. This has been done for changes in the size of the
            collection but not when one of the elements of the collection is modified as it is a bit
            tricky to detect unmanaged code that modifies the collection under our feet.
        </member>
        <member name="T:ExportOperations">
             <summary>Handles export operations without requiring any GUI.  
            
             </summary>
        </member>
        <member name="M:ExportOperations.#ctor(SWIGTYPE_p_vsc__Persistor,SWIGTYPE_p_vsc__Database)">
            <summary>
            </summary>
        </member>
        <member name="M:ExportOperations.exportDicomObject(System.Int32,System.String,System.String,System.Boolean,System.String)">
             <summary>Exports the dicom object to disk, in the specified folder. Names the files using
            the pattern "UID.dcm".  
            
             </summary>
        </member>
        <member name="M:ExportOperations.exportDicomObject(System.Int32,System.String,System.String,System.Boolean)">
             <summary>Exports the dicom object to disk, in the specified folder. Names the files using
            the pattern "UID.dcm".  
            
             </summary>
        </member>
        <member name="M:ExportOperations.exportDicomObject(System.Int32,System.String,System.String)">
             <summary>Exports the dicom object to disk, in the specified folder. Names the files using
            the pattern "UID.dcm".  
            
             </summary>
        </member>
        <member name="M:ExportOperations.patientIdStrFilenameFormatted">
             <summary>The following function will return the Patient Id string of the currently loaded
            patient. The returned string has been particularly formatted to be used as part
            of a filename. If an error occurs then the returned string is empty and the last
            error can be obtained using the "getErrorMessage()" function.  
            
             </summary>
        </member>
        <member name="M:ExportOperations.registrationNameStrFilenameFormatted">
             <summary>The following function will return the currently loaded name of a registration
            object (if any). The returned string has been particularly formatted to be used
            as part of a filename. If an error occurs then the returned string is empty and
            the last error can be obtained using the "getErrorMessage()" function.  
            
             </summary>
        </member>
        <member name="M:ExportOperations.documentNameStrFilenameFormatted(System.Int32)">
             <summary>The following function will return the name of the specified document. Please
            note that the the returned string has been particularly formatted to be used as
            part of a filename. If an error occurs then the returned string is empty and the
            last error can be obtained using the "getErrorMessage()" function.  
            
             </summary>
        </member>
        <member name="M:ExportOperations.exportReportDocument(System.Int32,System.String,System.String)">
             <summary>The following function will export the report (with the specified database
            record id) from the database and to the specified folder (the base filename will
            be used for naming of the report items in the exported folder). A value of
            'false' is returned if an error occurred.  
            
             </summary>
        </member>
        <member name="M:ExportOperations.getErrorMessage">
            <summary>
            </summary>
        </member>
        <member name="M:ExportOperations.getLocalizedErrorMessage">
            <summary>
            </summary>
        </member>
        <member name="T:FloatList.FloatListEnumerator">
            Note that the IEnumerator documentation requires an InvalidOperationException to be thrown
            whenever the collection is modified. This has been done for changes in the size of the
            collection but not when one of the elements of the collection is modified as it is a bit
            tricky to detect unmanaged code that modifies the collection under our feet.
        </member>
        <member name="T:Image2D">
            <summary>
            </summary>
        </member>
        <member name="M:Image2D.isLocked">
            <summary>
            </summary>
        </member>
        <member name="M:Image2D.getCreateDate">
             <summary>Returns the record creation date in ISO format.  
            
             </summary>
        </member>
        <member name="M:Image2D.getEditDate">
             <summary>Returns the record edit date in ISO format.  
            
             </summary>
        </member>
        <member name="M:Image2D.getPatient">
            <summary>
            </summary>
        </member>
        <member name="M:Image2D.getName">
            <summary>
            </summary>
        </member>
        <member name="M:Image2D.getInstanceUID">
            <summary>
            </summary>
        </member>
        <member name="M:Image2D.getType">
            <summary>
            </summary>
        </member>
        <member name="M:Image2D.getModality">
            <summary>
            </summary>
        </member>
        <member name="M:Image2D.getStudyUID">
            <summary>
            </summary>
        </member>
        <member name="M:Image2D.getSeriesUID">
            <summary>
            </summary>
        </member>
        <member name="M:Image2D.getStudyDate">
             <summary>Returns the study date in ISO format.  
            
             </summary>
        </member>
        <member name="T:Image2DList.Image2DListEnumerator">
            Note that the IEnumerator documentation requires an InvalidOperationException to be thrown
            whenever the collection is modified. This has been done for changes in the size of the
            collection but not when one of the elements of the collection is modified as it is a bit
            tricky to detect unmanaged code that modifies the collection under our feet.
        </member>
        <member name="T:ImportOperations">
             <summary>Handles import operations without requiring any GUI.  
            
             </summary>
        </member>
        <member name="M:ImportOperations.#ctor(SWIGTYPE_p_vsc__Persistor,SWIGTYPE_p_vsc__Database)">
            <summary>
            </summary>
        </member>
        <member name="M:ImportOperations.importDirectory(System.String,System.Boolean)">
             <summary>Imports DICOM files from a directory.  
              
            
             </summary>
            
             <param name="path">
            the directory to import  
            
            </param>
            
            
             <param name="recursive">
            if the directory should be recursively searched for DICOM files  
            
            </param>
        </member>
        <member name="M:ImportOperations.importEclipseTrePointSet(System.String,System.String)">
             <summary>The following function will import the specified TRE Point Set that has been
            export from the Eclipse database (note, this is a custom CSV file-format). The
            function will return the record id of the point set record, otherwise a '-1'
            value is returned. Note, the Registration Commissioning Name is a string which
            represents the name of the registration commissioning object that we'll be
            saving in the database.  
            
             </summary>
        </member>
        <member name="M:ImportOperations.getErrorMessage">
            <summary>
            </summary>
        </member>
        <member name="M:ImportOperations.getLocalizedErrorMessage">
            <summary>
            </summary>
        </member>
        <member name="T:IntList.IntListEnumerator">
            Note that the IEnumerator documentation requires an InvalidOperationException to be thrown
            whenever the collection is modified. This has been done for changes in the size of the
            collection but not when one of the elements of the collection is modified as it is a bit
            tricky to detect unmanaged code that modifies the collection under our feet.
        </member>
        <member name="T:ManualRegistrationSettingsStructure">
             <summary>Settings for manually aligned rigid registration.  
            
            Attributes
            ----------
            * `registrationMatrix` : `vsc::MatrixR44d`  
                The rigid transformation matrix of the registration. Defaults to the
                identity.  
            
             </summary>
        </member>
        <member name="M:ManualRegistrationSettingsStructure.#ctor">
            <summary>
            </summary>
        </member>
        <member name="T:MatrixR22d">
             <summary>The MatrixR class implements fixed size matrices with arbitrary element types
            for use with transform and vector operations. This matrix is stored and
            processed in column major order in order to best conform to the OpenGL matrix
            standard format.  
            *NR* is the number of rows, which must be greater than zero. *NC* is the number
            of columns, which must be greater than zero. *E* is the element type, typically
            <c>double</c> or <c>float</c>.  
            
            Attributes
            ----------
            * `num_rows` : `const unsigned int`  
            
            * `num_cols` : `const unsigned int`  
            
             </summary>
        </member>
        <member name="M:MatrixR22d.#ctor(System.Collections.Generic.ICollection{System.Double})">
            <summary>Construct a MatrixR22d from a collection of values.</summary>
            <remarks><code>values</code> must have size (2 * 2). and be in column-major order.</remarks>
            <exception cref="T:System.ArgumentException">If <code>values</code> is not size (2 * 2).</exception>
        </member>
        <member name="M:MatrixR22d.#ctor(System.Double[])">
            <summary>Construct a MatrixR22d from a collection of values.</summary>
            <remarks>(2 * 2) parameters must be given.</remarks>
            <exception cref="T:System.ArgumentException">If exactly (2 * 2) parameters are not given.</exception>
        </member>
        <member name="M:MatrixR22d.identity">
             <summary>Sets the matrix back to identity. A compilation error will be generated if this
            function is called for a class that does not represent square matrices.  
            
             </summary>
        </member>
        <member name="M:MatrixR22d.#ctor">
            <summary>
            </summary>
        </member>
        <member name="M:MatrixR22d.#ctor(MatrixR22d)">
            <summary>
            </summary>
        </member>
        <member name="M:MatrixR22d.#ctor(SWIGTYPE_p_double)">
            <summary>
            </summary>
        </member>
        <member name="M:MatrixR22d.elements">
             <summary>Returns a pointer to an array containing the elements of this matrix, stored in
            row-major order. The caller must not try to deallocate this array. Assigning the
            elements of this array will modify the matrix.  
            
             </summary>
        </member>
        <member name="M:MatrixR22d.setElements(SWIGTYPE_p_double)">
             <summary>Copies the elements from *elementArray* to this matrix. The array must contain
            *NROWS* by *NCOLUMNS* elements, stored in column major order.  
            
             </summary>
        </member>
        <member name="M:MatrixR22d.transpose">
             <summary>Returns the transpose of *matrix*.  
            
             </summary>
        </member>
        <member name="M:MatrixR22d.invert">
             <summary>Replaces this matrix by its inverse (in-place inversion). If this matrix is
            singular or near singular, the result is undefined. It is likely that
            <c>finite(*this)</c> returns false in that case. The current implementation
            contains a run time assert if the matrix is not square  
            TodoAdd compilation error to be generated if the matrix is not square or
            contains
            non floating-point elements.  
              
            
             </summary>
        </member>
        <member name="M:MatrixR22d.isRigid">
             <summary>Checks to see if a matrix is a pure Rigid (with no scale).  
            
             </summary>
        </member>
        <member name="M:MatrixR22d.extractScale(SWIGTYPE_p_vsc__VectorRT_vsc__MatrixRT_2_2_double_t__num_rows_1_double_t)">
             <summary>Extract the scale from a matrix representing a RIGID_SCALE. Note that this
            method assumes an order where the rigid occurs first, and then the scale. This
            method should not be used on an affine matrix which contains a skew.  
            
             </summary>
        </member>
        <member name="M:MatrixR22d.extractTranslation(SWIGTYPE_p_vsc__VectorRT_vsc__MatrixRT_2_2_double_t__num_rows_1_double_t)">
             <summary>Extract the translation from the current matrix. Note that this method assumes
            an order where the rigid occurs first, and then the scale.  
            
             </summary>
        </member>
        <member name="T:MatrixR22i">
             <summary>The MatrixR class implements fixed size matrices with arbitrary element types
            for use with transform and vector operations. This matrix is stored and
            processed in column major order in order to best conform to the OpenGL matrix
            standard format.  
            *NR* is the number of rows, which must be greater than zero. *NC* is the number
            of columns, which must be greater than zero. *E* is the element type, typically
            <c>double</c> or <c>float</c>.  
            
            Attributes
            ----------
            * `num_rows` : `const unsigned int`  
            
            * `num_cols` : `const unsigned int`  
            
             </summary>
        </member>
        <member name="M:MatrixR22i.#ctor(System.Collections.Generic.ICollection{System.Int32})">
            <summary>Construct a MatrixR22i from a collection of values.</summary>
            <remarks><code>values</code> must have size (2 * 2). and be in column-major order.</remarks>
            <exception cref="T:System.ArgumentException">If <code>values</code> is not size (2 * 2).</exception>
        </member>
        <member name="M:MatrixR22i.#ctor(System.Int32[])">
            <summary>Construct a MatrixR22i from a collection of values.</summary>
            <remarks>(2 * 2) parameters must be given.</remarks>
            <exception cref="T:System.ArgumentException">If exactly (2 * 2) parameters are not given.</exception>
        </member>
        <member name="M:MatrixR22i.identity">
             <summary>Sets the matrix back to identity. A compilation error will be generated if this
            function is called for a class that does not represent square matrices.  
            
             </summary>
        </member>
        <member name="M:MatrixR22i.#ctor">
            <summary>
            </summary>
        </member>
        <member name="M:MatrixR22i.#ctor(MatrixR22i)">
            <summary>
            </summary>
        </member>
        <member name="M:MatrixR22i.#ctor(SWIGTYPE_p_int)">
            <summary>
            </summary>
        </member>
        <member name="M:MatrixR22i.elements">
             <summary>Returns a pointer to an array containing the elements of this matrix, stored in
            row-major order. The caller must not try to deallocate this array. Assigning the
            elements of this array will modify the matrix.  
            
             </summary>
        </member>
        <member name="M:MatrixR22i.setElements(SWIGTYPE_p_int)">
             <summary>Copies the elements from *elementArray* to this matrix. The array must contain
            *NROWS* by *NCOLUMNS* elements, stored in column major order.  
            
             </summary>
        </member>
        <member name="M:MatrixR22i.transpose">
             <summary>Returns the transpose of *matrix*.  
            
             </summary>
        </member>
        <member name="M:MatrixR22i.invert">
             <summary>Replaces this matrix by its inverse (in-place inversion). If this matrix is
            singular or near singular, the result is undefined. It is likely that
            <c>finite(*this)</c> returns false in that case. The current implementation
            contains a run time assert if the matrix is not square  
            TodoAdd compilation error to be generated if the matrix is not square or
            contains
            non floating-point elements.  
              
            
             </summary>
        </member>
        <member name="M:MatrixR22i.isRigid">
             <summary>Checks to see if a matrix is a pure Rigid (with no scale).  
            
             </summary>
        </member>
        <member name="M:MatrixR22i.extractScale(SWIGTYPE_p_vsc__VectorRT_vsc__MatrixRT_2_2_int_t__num_rows_1_double_t)">
             <summary>Extract the scale from a matrix representing a RIGID_SCALE. Note that this
            method assumes an order where the rigid occurs first, and then the scale. This
            method should not be used on an affine matrix which contains a skew.  
            
             </summary>
        </member>
        <member name="M:MatrixR22i.extractTranslation(SWIGTYPE_p_vsc__VectorRT_vsc__MatrixRT_2_2_int_t__num_rows_1_double_t)">
             <summary>Extract the translation from the current matrix. Note that this method assumes
            an order where the rigid occurs first, and then the scale.  
            
             </summary>
        </member>
        <member name="T:MatrixR33d">
             <summary>The MatrixR class implements fixed size matrices with arbitrary element types
            for use with transform and vector operations. This matrix is stored and
            processed in column major order in order to best conform to the OpenGL matrix
            standard format.  
            *NR* is the number of rows, which must be greater than zero. *NC* is the number
            of columns, which must be greater than zero. *E* is the element type, typically
            <c>double</c> or <c>float</c>.  
            
            Attributes
            ----------
            * `num_rows` : `const unsigned int`  
            
            * `num_cols` : `const unsigned int`  
            
             </summary>
        </member>
        <member name="M:MatrixR33d.#ctor(System.Collections.Generic.ICollection{System.Double})">
            <summary>Construct a MatrixR33d from a collection of values.</summary>
            <remarks><code>values</code> must have size (3 * 3). and be in column-major order.</remarks>
            <exception cref="T:System.ArgumentException">If <code>values</code> is not size (3 * 3).</exception>
        </member>
        <member name="M:MatrixR33d.#ctor(System.Double[])">
            <summary>Construct a MatrixR33d from a collection of values.</summary>
            <remarks>(3 * 3) parameters must be given.</remarks>
            <exception cref="T:System.ArgumentException">If exactly (3 * 3) parameters are not given.</exception>
        </member>
        <member name="M:MatrixR33d.identity">
             <summary>Sets the matrix back to identity. A compilation error will be generated if this
            function is called for a class that does not represent square matrices.  
            
             </summary>
        </member>
        <member name="M:MatrixR33d.#ctor">
            <summary>
            </summary>
        </member>
        <member name="M:MatrixR33d.#ctor(MatrixR33d)">
            <summary>
            </summary>
        </member>
        <member name="M:MatrixR33d.#ctor(SWIGTYPE_p_double)">
            <summary>
            </summary>
        </member>
        <member name="M:MatrixR33d.elements">
             <summary>Returns a pointer to an array containing the elements of this matrix, stored in
            row-major order. The caller must not try to deallocate this array. Assigning the
            elements of this array will modify the matrix.  
            
             </summary>
        </member>
        <member name="M:MatrixR33d.setElements(SWIGTYPE_p_double)">
             <summary>Copies the elements from *elementArray* to this matrix. The array must contain
            *NROWS* by *NCOLUMNS* elements, stored in column major order.  
            
             </summary>
        </member>
        <member name="M:MatrixR33d.transpose">
             <summary>Returns the transpose of *matrix*.  
            
             </summary>
        </member>
        <member name="M:MatrixR33d.invert">
             <summary>Replaces this matrix by its inverse (in-place inversion). If this matrix is
            singular or near singular, the result is undefined. It is likely that
            <c>finite(*this)</c> returns false in that case. The current implementation
            contains a run time assert if the matrix is not square  
            TodoAdd compilation error to be generated if the matrix is not square or
            contains
            non floating-point elements.  
              
            
             </summary>
        </member>
        <member name="M:MatrixR33d.isRigid">
             <summary>Checks to see if a matrix is a pure Rigid (with no scale).  
            
             </summary>
        </member>
        <member name="M:MatrixR33d.extractScale(SWIGTYPE_p_vsc__VectorRT_vsc__MatrixRT_3_3_double_t__num_rows_1_double_t)">
             <summary>Extract the scale from a matrix representing a RIGID_SCALE. Note that this
            method assumes an order where the rigid occurs first, and then the scale. This
            method should not be used on an affine matrix which contains a skew.  
            
             </summary>
        </member>
        <member name="M:MatrixR33d.extractTranslation(SWIGTYPE_p_vsc__VectorRT_vsc__MatrixRT_3_3_double_t__num_rows_1_double_t)">
             <summary>Extract the translation from the current matrix. Note that this method assumes
            an order where the rigid occurs first, and then the scale.  
            
             </summary>
        </member>
        <member name="T:MatrixR33f">
             <summary>The MatrixR class implements fixed size matrices with arbitrary element types
            for use with transform and vector operations. This matrix is stored and
            processed in column major order in order to best conform to the OpenGL matrix
            standard format.  
            *NR* is the number of rows, which must be greater than zero. *NC* is the number
            of columns, which must be greater than zero. *E* is the element type, typically
            <c>double</c> or <c>float</c>.  
            
            Attributes
            ----------
            * `num_rows` : `const unsigned int`  
            
            * `num_cols` : `const unsigned int`  
            
             </summary>
        </member>
        <member name="M:MatrixR33f.#ctor(System.Collections.Generic.ICollection{System.Single})">
            <summary>Construct a MatrixR33f from a collection of values.</summary>
            <remarks><code>values</code> must have size (3 * 3). and be in column-major order.</remarks>
            <exception cref="T:System.ArgumentException">If <code>values</code> is not size (3 * 3).</exception>
        </member>
        <member name="M:MatrixR33f.#ctor(System.Single[])">
            <summary>Construct a MatrixR33f from a collection of values.</summary>
            <remarks>(3 * 3) parameters must be given.</remarks>
            <exception cref="T:System.ArgumentException">If exactly (3 * 3) parameters are not given.</exception>
        </member>
        <member name="M:MatrixR33f.identity">
             <summary>Sets the matrix back to identity. A compilation error will be generated if this
            function is called for a class that does not represent square matrices.  
            
             </summary>
        </member>
        <member name="M:MatrixR33f.#ctor">
            <summary>
            </summary>
        </member>
        <member name="M:MatrixR33f.#ctor(MatrixR33f)">
            <summary>
            </summary>
        </member>
        <member name="M:MatrixR33f.#ctor(SWIGTYPE_p_float)">
            <summary>
            </summary>
        </member>
        <member name="M:MatrixR33f.elements">
             <summary>Returns a pointer to an array containing the elements of this matrix, stored in
            row-major order. The caller must not try to deallocate this array. Assigning the
            elements of this array will modify the matrix.  
            
             </summary>
        </member>
        <member name="M:MatrixR33f.setElements(SWIGTYPE_p_float)">
             <summary>Copies the elements from *elementArray* to this matrix. The array must contain
            *NROWS* by *NCOLUMNS* elements, stored in column major order.  
            
             </summary>
        </member>
        <member name="M:MatrixR33f.transpose">
             <summary>Returns the transpose of *matrix*.  
            
             </summary>
        </member>
        <member name="M:MatrixR33f.invert">
             <summary>Replaces this matrix by its inverse (in-place inversion). If this matrix is
            singular or near singular, the result is undefined. It is likely that
            <c>finite(*this)</c> returns false in that case. The current implementation
            contains a run time assert if the matrix is not square  
            TodoAdd compilation error to be generated if the matrix is not square or
            contains
            non floating-point elements.  
              
            
             </summary>
        </member>
        <member name="M:MatrixR33f.isRigid">
             <summary>Checks to see if a matrix is a pure Rigid (with no scale).  
            
             </summary>
        </member>
        <member name="M:MatrixR33f.extractScale(SWIGTYPE_p_vsc__VectorRT_vsc__MatrixRT_3_3_float_t__num_rows_1_double_t)">
             <summary>Extract the scale from a matrix representing a RIGID_SCALE. Note that this
            method assumes an order where the rigid occurs first, and then the scale. This
            method should not be used on an affine matrix which contains a skew.  
            
             </summary>
        </member>
        <member name="M:MatrixR33f.extractTranslation(SWIGTYPE_p_vsc__VectorRT_vsc__MatrixRT_3_3_float_t__num_rows_1_double_t)">
             <summary>Extract the translation from the current matrix. Note that this method assumes
            an order where the rigid occurs first, and then the scale.  
            
             </summary>
        </member>
        <member name="T:MatrixR44d">
             <summary>The MatrixR class implements fixed size matrices with arbitrary element types
            for use with transform and vector operations. This matrix is stored and
            processed in column major order in order to best conform to the OpenGL matrix
            standard format.  
            *NR* is the number of rows, which must be greater than zero. *NC* is the number
            of columns, which must be greater than zero. *E* is the element type, typically
            <c>double</c> or <c>float</c>.  
            
            Attributes
            ----------
            * `num_rows` : `const unsigned int`  
            
            * `num_cols` : `const unsigned int`  
            
             </summary>
        </member>
        <member name="M:MatrixR44d.#ctor(System.Collections.Generic.ICollection{System.Double})">
            <summary>Construct a MatrixR44d from a collection of values.</summary>
            <remarks><code>values</code> must have size (4 * 4). and be in column-major order.</remarks>
            <exception cref="T:System.ArgumentException">If <code>values</code> is not size (4 * 4).</exception>
        </member>
        <member name="M:MatrixR44d.#ctor(System.Double[])">
            <summary>Construct a MatrixR44d from a collection of values.</summary>
            <remarks>(4 * 4) parameters must be given.</remarks>
            <exception cref="T:System.ArgumentException">If exactly (4 * 4) parameters are not given.</exception>
        </member>
        <member name="M:MatrixR44d.identity">
             <summary>Sets the matrix back to identity. A compilation error will be generated if this
            function is called for a class that does not represent square matrices.  
            
             </summary>
        </member>
        <member name="M:MatrixR44d.#ctor">
            <summary>
            </summary>
        </member>
        <member name="M:MatrixR44d.#ctor(MatrixR44d)">
            <summary>
            </summary>
        </member>
        <member name="M:MatrixR44d.#ctor(SWIGTYPE_p_double)">
            <summary>
            </summary>
        </member>
        <member name="M:MatrixR44d.elements">
             <summary>Returns a pointer to an array containing the elements of this matrix, stored in
            row-major order. The caller must not try to deallocate this array. Assigning the
            elements of this array will modify the matrix.  
            
             </summary>
        </member>
        <member name="M:MatrixR44d.setElements(SWIGTYPE_p_double)">
             <summary>Copies the elements from *elementArray* to this matrix. The array must contain
            *NROWS* by *NCOLUMNS* elements, stored in column major order.  
            
             </summary>
        </member>
        <member name="M:MatrixR44d.transpose">
             <summary>Returns the transpose of *matrix*.  
            
             </summary>
        </member>
        <member name="M:MatrixR44d.invert">
             <summary>Replaces this matrix by its inverse (in-place inversion). If this matrix is
            singular or near singular, the result is undefined. It is likely that
            <c>finite(*this)</c> returns false in that case. The current implementation
            contains a run time assert if the matrix is not square  
            TodoAdd compilation error to be generated if the matrix is not square or
            contains
            non floating-point elements.  
              
            
             </summary>
        </member>
        <member name="M:MatrixR44d.isRigid">
             <summary>Checks to see if a matrix is a pure Rigid (with no scale).  
            
             </summary>
        </member>
        <member name="M:MatrixR44d.extractScale(SWIGTYPE_p_vsc__VectorRT_vsc__MatrixRT_4_4_double_t__num_rows_1_double_t)">
             <summary>Extract the scale from a matrix representing a RIGID_SCALE. Note that this
            method assumes an order where the rigid occurs first, and then the scale. This
            method should not be used on an affine matrix which contains a skew.  
            
             </summary>
        </member>
        <member name="M:MatrixR44d.extractTranslation(SWIGTYPE_p_vsc__VectorRT_vsc__MatrixRT_4_4_double_t__num_rows_1_double_t)">
             <summary>Extract the translation from the current matrix. Note that this method assumes
            an order where the rigid occurs first, and then the scale.  
            
             </summary>
        </member>
        <member name="T:MatrixR44f">
             <summary>The MatrixR class implements fixed size matrices with arbitrary element types
            for use with transform and vector operations. This matrix is stored and
            processed in column major order in order to best conform to the OpenGL matrix
            standard format.  
            *NR* is the number of rows, which must be greater than zero. *NC* is the number
            of columns, which must be greater than zero. *E* is the element type, typically
            <c>double</c> or <c>float</c>.  
            
            Attributes
            ----------
            * `num_rows` : `const unsigned int`  
            
            * `num_cols` : `const unsigned int`  
            
             </summary>
        </member>
        <member name="M:MatrixR44f.#ctor(System.Collections.Generic.ICollection{System.Single})">
            <summary>Construct a MatrixR44f from a collection of values.</summary>
            <remarks><code>values</code> must have size (4 * 4). and be in column-major order.</remarks>
            <exception cref="T:System.ArgumentException">If <code>values</code> is not size (4 * 4).</exception>
        </member>
        <member name="M:MatrixR44f.#ctor(System.Single[])">
            <summary>Construct a MatrixR44f from a collection of values.</summary>
            <remarks>(4 * 4) parameters must be given.</remarks>
            <exception cref="T:System.ArgumentException">If exactly (4 * 4) parameters are not given.</exception>
        </member>
        <member name="M:MatrixR44f.identity">
             <summary>Sets the matrix back to identity. A compilation error will be generated if this
            function is called for a class that does not represent square matrices.  
            
             </summary>
        </member>
        <member name="M:MatrixR44f.#ctor">
            <summary>
            </summary>
        </member>
        <member name="M:MatrixR44f.#ctor(MatrixR44f)">
            <summary>
            </summary>
        </member>
        <member name="M:MatrixR44f.#ctor(SWIGTYPE_p_float)">
            <summary>
            </summary>
        </member>
        <member name="M:MatrixR44f.elements">
             <summary>Returns a pointer to an array containing the elements of this matrix, stored in
            row-major order. The caller must not try to deallocate this array. Assigning the
            elements of this array will modify the matrix.  
            
             </summary>
        </member>
        <member name="M:MatrixR44f.setElements(SWIGTYPE_p_float)">
             <summary>Copies the elements from *elementArray* to this matrix. The array must contain
            *NROWS* by *NCOLUMNS* elements, stored in column major order.  
            
             </summary>
        </member>
        <member name="M:MatrixR44f.transpose">
             <summary>Returns the transpose of *matrix*.  
            
             </summary>
        </member>
        <member name="M:MatrixR44f.invert">
             <summary>Replaces this matrix by its inverse (in-place inversion). If this matrix is
            singular or near singular, the result is undefined. It is likely that
            <c>finite(*this)</c> returns false in that case. The current implementation
            contains a run time assert if the matrix is not square  
            TodoAdd compilation error to be generated if the matrix is not square or
            contains
            non floating-point elements.  
              
            
             </summary>
        </member>
        <member name="M:MatrixR44f.isRigid">
             <summary>Checks to see if a matrix is a pure Rigid (with no scale).  
            
             </summary>
        </member>
        <member name="M:MatrixR44f.extractScale(SWIGTYPE_p_vsc__VectorRT_vsc__MatrixRT_4_4_float_t__num_rows_1_double_t)">
             <summary>Extract the scale from a matrix representing a RIGID_SCALE. Note that this
            method assumes an order where the rigid occurs first, and then the scale. This
            method should not be used on an affine matrix which contains a skew.  
            
             </summary>
        </member>
        <member name="M:MatrixR44f.extractTranslation(SWIGTYPE_p_vsc__VectorRT_vsc__MatrixRT_4_4_float_t__num_rows_1_double_t)">
             <summary>Extract the translation from the current matrix. Note that this method assumes
            an order where the rigid occurs first, and then the scale.  
            
             </summary>
        </member>
        <member name="T:Patient">
            <summary>
            </summary>
        </member>
        <member name="M:Patient.getPatientId">
            <summary>
            </summary>
        </member>
        <member name="M:Patient.getCreateDate">
             <summary>Returns the record creation date in ISO format.  
            
             </summary>
        </member>
        <member name="M:Patient.getEditDate">
             <summary>Returns the record edit date in ISO format.  
            
             </summary>
        </member>
        <member name="M:Patient.getDateOfBirth">
             <summary>Returns the date of birth in ISO format.  
            
             </summary>
        </member>
        <member name="M:Patient.getFirstName">
            <summary>
            </summary>
        </member>
        <member name="M:Patient.getLastName">
            <summary>
            </summary>
        </member>
        <member name="M:Patient.getSex">
            <summary>
            </summary>
        </member>
        <member name="M:Patient.isLocked">
            <summary>
            </summary>
        </member>
        <member name="M:Patient.getVolumes">
            <summary>
            </summary>
        </member>
        <member name="M:Patient.getVolumes(System.String)">
            <summary>
            </summary>
        </member>
        <member name="M:Patient.getPlans">
            <summary>
            </summary>
        </member>
        <member name="T:PatientDataItem">
            <summary>
            </summary>
        </member>
        <member name="M:PatientDataItem.getVelocityId">
             <summary>Returns the internal Velocity id for this object.  
            
             </summary>
        </member>
        <member name="M:PatientDataItem.isValid">
             <summary>Returns whether this is a valid object. Invalid objects may result from errors
            during querying or other operation.  
            
             </summary>
        </member>
        <member name="T:PatientDataOperations">
            <summary>
            </summary>
        </member>
        <member name="M:PatientDataOperations.#ctor(SWIGTYPE_p_vsc__Persistor,SWIGTYPE_p_vsc__Database)">
            <summary>
            </summary>
        </member>
        <member name="M:PatientDataOperations.getPatients">
            <summary>
            </summary>
        </member>
        <member name="M:PatientDataOperations.getPatient(System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:PatientDataOperations.getPatientByPatientId(System.String)">
            <summary>
            </summary>
        </member>
        <member name="M:PatientDataOperations.getVolume(System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:PatientDataOperations.getVolumeByUID(System.String)">
            <summary>
            </summary>
        </member>
        <member name="M:PatientDataOperations.getRegistration(System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:PatientDataOperations.getStructure(System.Int32)">
             <summary>Fetch a structure by its internal id.  
            
             </summary>
        </member>
        <member name="M:PatientDataOperations.getStructureSet(System.Int32)">
             <summary>Fetch a structure set by its internal id.  
            
             </summary>
        </member>
        <member name="M:PatientDataOperations.getStructureSetByUID(System.String)">
             <summary>Fetch a structure set by its DICOM instance UID.  
            
             </summary>
        </member>
        <member name="M:PatientDataOperations.getPlan(System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:PatientDataOperations.getRegistrationCommissioningMarkerList(System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:PatientDataOperations.getErrorMessage">
            <summary>
            </summary>
        </member>
        <member name="M:PatientDataOperations.getLocalizedErrorMessage">
            <summary>
            </summary>
        </member>
        <member name="T:PatientList.PatientListEnumerator">
            Note that the IEnumerator documentation requires an InvalidOperationException to be thrown
            whenever the collection is modified. This has been done for changes in the size of the
            collection but not when one of the elements of the collection is modified as it is a bit
            tricky to detect unmanaged code that modifies the collection under our feet.
        </member>
        <member name="T:Plan">
            <summary>
            </summary>
        </member>
        <member name="M:Plan.isLocked">
            <summary>
            </summary>
        </member>
        <member name="M:Plan.getCreateDate">
             <summary>Returns the record creation date in ISO format.  
            
             </summary>
        </member>
        <member name="M:Plan.getEditDate">
             <summary>Returns the record edit date in ISO format.  
            
             </summary>
        </member>
        <member name="M:Plan.getVolume">
            <summary>
            </summary>
        </member>
        <member name="M:Plan.getVolumeVelocityId">
            <summary>
            </summary>
        </member>
        <member name="M:Plan.getDoseVolumeIds">
             <summary>Returns the Velocity ids of any Dose volumes referencing this plan.  
            
             </summary>
        </member>
        <member name="M:Plan.getDoseVolumes">
             <summary>Returns any Dose volumes referencing this plan.  
            
             </summary>
        </member>
        <member name="M:Plan.getName">
            <summary>
            </summary>
        </member>
        <member name="M:Plan.getInstanceUID">
            <summary>
            </summary>
        </member>
        <member name="M:Plan.getStudyUID">
            <summary>
            </summary>
        </member>
        <member name="M:Plan.getSeriesUID">
            <summary>
            </summary>
        </member>
        <member name="M:Plan.getStudyDate">
            <summary>
            </summary>
        </member>
        <member name="M:Plan.getStructureSetUID">
            <summary>
            </summary>
        </member>
        <member name="M:Plan.getStructureSet">
            <summary>
            </summary>
        </member>
        <member name="M:Plan.getStructureVelocityIds">
            <summary>
            </summary>
        </member>
        <member name="M:Plan.getStructures">
            <summary>
            </summary>
        </member>
        <member name="T:PlanList.PlanListEnumerator">
            Note that the IEnumerator documentation requires an InvalidOperationException to be thrown
            whenever the collection is modified. This has been done for changes in the size of the
            collection but not when one of the elements of the collection is modified as it is a bit
            tricky to detect unmanaged code that modifies the collection under our feet.
        </member>
        <member name="T:Registration">
            <summary>
            </summary>
        </member>
        <member name="M:Registration.isLocked">
            <summary>
            </summary>
        </member>
        <member name="M:Registration.getCreateDate">
             <summary>Returns the record creation date in ISO format.  
            
             </summary>
        </member>
        <member name="M:Registration.getEditDate">
             <summary>Returns the record edit date in ISO format.  
            
             </summary>
        </member>
        <member name="M:Registration.getName">
            <summary>
            </summary>
        </member>
        <member name="M:Registration.getInstanceUID">
            <summary>
            </summary>
        </member>
        <member name="M:Registration.getSourceVolume">
            <summary>
            </summary>
        </member>
        <member name="M:Registration.getTargetVolume">
            <summary>
            </summary>
        </member>
        <member name="M:Registration.getType">
            <summary>
            </summary>
        </member>
        <member name="M:Registration.getDicomRegistrationUID">
            <summary>
            </summary>
        </member>
        <member name="T:RegistrationCommissioningMarkerList">
            <summary>
            </summary>
        </member>
        <member name="M:RegistrationCommissioningMarkerList.getPrimaryVolume">
            <summary>
            </summary>
        </member>
        <member name="M:RegistrationCommissioningMarkerList.getSecondaryVolume">
            <summary>
            </summary>
        </member>
        <member name="M:RegistrationCommissioningMarkerList.getCreateDate">
             <summary>Returns the record creation date in ISO format.  
            
             </summary>
        </member>
        <member name="M:RegistrationCommissioningMarkerList.getName">
            <summary>
            </summary>
        </member>
        <member name="M:RegistrationCommissioningMarkerList.getRegistrationMarkerList">
            <summary>
            </summary>
        </member>
        <member name="T:RegistrationCommissioningMarkerLists.RegistrationCommissioningMarkerListsEnumerator">
            Note that the IEnumerator documentation requires an InvalidOperationException to be thrown
            whenever the collection is modified. This has been done for changes in the size of the
            collection but not when one of the elements of the collection is modified as it is a bit
            tricky to detect unmanaged code that modifies the collection under our feet.
        </member>
        <member name="T:RegistrationList.RegistrationListEnumerator">
            Note that the IEnumerator documentation requires an InvalidOperationException to be thrown
            whenever the collection is modified. This has been done for changes in the size of the
            collection but not when one of the elements of the collection is modified as it is a bit
            tricky to detect unmanaged code that modifies the collection under our feet.
        </member>
        <member name="T:RegistrationMarker">
            <summary>
            </summary>
        </member>
        <member name="M:RegistrationMarker.getPrimaryLocation">
            <summary>
            </summary>
        </member>
        <member name="M:RegistrationMarker.getSecondaryLocation">
            <summary>
            </summary>
        </member>
        <member name="M:RegistrationMarker.getName">
            <summary>
            </summary>
        </member>
        <member name="M:RegistrationMarker.isConfirmed">
            <summary>
            </summary>
        </member>
        <member name="T:RegistrationMarkerList.RegistrationMarkerListEnumerator">
            Note that the IEnumerator documentation requires an InvalidOperationException to be thrown
            whenever the collection is modified. This has been done for changes in the size of the
            collection but not when one of the elements of the collection is modified as it is a bit
            tricky to detect unmanaged code that modifies the collection under our feet.
        </member>
        <member name="T:RegistrationOperations">
             <summary>Handles registration operations without requiring any GUI.  
            
             </summary>
        </member>
        <member name="M:RegistrationOperations.#ctor(SWIGTYPE_p_vsc__Persistor,SWIGTYPE_p_vsc__Database)">
            <summary>
            </summary>
        </member>
        <member name="M:RegistrationOperations.computeJacobian">
             <summary>Computes the Jacobian using the currently loaded volumes and registration.  
            On error, the data member of the volume data will be empty.  
            
             </summary>
        </member>
        <member name="M:RegistrationOperations.getTransformedRegistrationCommissioningMarkers(System.Int32)">
             <summary>Returns the list of registration commissioned markers transformed into various
            coordinate systems. The marker list must belong to the current primary and
            secondary volumes and will be transformed using the currently loaded
            registration.  
              
            
             </summary>
            
             <param name="markerListId">
            the Velocity id of the registration commissioning marker list  
            
            </param>
            <returns>
            a pair with the first item indicating success or failure and the second being
            
            the list, populated only if the first entry is true  
            
            </returns>
        </member>
        <member name="M:RegistrationOperations.createNewRegistration(System.String)">
             <summary>The following function will create a new rigid registration with the specified
            name and save it into the database. Returns 'true' if successful.  
            
             </summary>
        </member>
        <member name="M:RegistrationOperations.saveRegistration">
             <summary>The following function will save the currently loaded registration or
            deformation object from the persistor back into the database and will cerate a
            new DICOM file with a new SOPInstanceUID. Returns a new handle that should be
            used due to versioning.  
            
             </summary>
        </member>
        <member name="M:RegistrationOperations.performManualAlignmentDICOM(ManualRegistrationSettingsStructure)">
             <summary>Performs a manual alignment between the two loaded volumes in the persistor.
            Simply resets the registration matrix as it is specified within the settings
            object.  
            Note, returns an error if the currently loaded registration is a deformable.  
            Coordinates should be DICOM coordinates.  
              
            
             </summary>
            
             <param name="settings">
            the alignment settings  
            
            </param>
            <returns>
            if successful  
            
            </returns>
        </member>
        <member name="M:RegistrationOperations.performManualAlignment(ManualRegistrationSettingsStructure)">
             <summary>The function will perform a manual alignment between the two loaded volumes in
            the persistor. It simply resets the registration matrix as it is specified
            within the settings object.  
            Note, this function will return an error if there is a deformation object that's
            currently set in the persistor.  
            All coordinates must be in Velocity's internal coordinate space. Use
            RegistrationOperations::performManualAlignmentDICOM for DICOM coordinates.  
              
            
             </summary>
            
             <param name="settings">
            the alignment settings  
            
            </param>
            <returns>
            if successful  
            
            </returns>
        </member>
        <member name="M:RegistrationOperations.performRigidRegistrationDICOM(RigidRegistrationSettingsStructure)">
             <summary>Performs a rigid registration between the two loaded volumes in the engine.
            Returns an error if there is no registration object or the registration is a
            deformable.  
            All coordinates and image values are in DICOM coordinates and original volume
            units.  
              
            
             </summary>
            
             <param name="settings">
            the registration settings  
            
            </param>
            <returns>
            if successful  
            
            </returns>
        </member>
        <member name="M:RegistrationOperations.performRigidRegistration(RigidRegistrationSettingsStructure)">
             <summary>Performs a rigid registration between the two loaded volumes in the engine.
            Returns an error if there is no registration object or the registration is a
            deformable.  
            All coordinates and image values must be in Velocity's internal coordinate space
            and units. Use RegistrationOperations::performRigidRegistrationDICOM for DICOM
            coordinates and original volume values.  
              
            
             </summary>
            
             <param name="settings">
            the registration settings  
            
            </param>
            <returns>
            if successful  
            
            </returns>
        </member>
        <member name="M:RegistrationOperations.performBsplineRegistrationDICOM(BSplineDeformableRegistrationSettingsStructure)">
             <summary>Performs a BSpline deformable registration between the two loaded volumes.    If
            the current registration is a deformable, it will be restarted. If the current
            registration is not a deformable, it will be converted into one by this process.  
            Note, this function will restart a deformable object if such an object is
            currently loaded into memory. A value of 'true' is returned if successful.  
            All coordinates and image values are in DICOM coordinates and original volume
            units.  
              
            
             </summary>
            
             <param name="settings">
            the deformable algorithm settings  
            
            </param>
            <returns>
            if successful  
            
            </returns>
        </member>
        <member name="M:RegistrationOperations.performBsplineRegistration(BSplineDeformableRegistrationSettingsStructure)">
             <summary>Performs a BSpline deformable registration between the two loaded volumes.    If
            the current registration is a deformable, it will be restarted. If the current
            registration is not a deformable, it will be converted into one by this process.  
            Note, this function will restart a deformable object if such an object is
            currently loaded into memory. A value of 'true' is returned if successful.  
            All coordinates and image values must be in Velocity's internal coordinate space
            and units. Use RegistrationOperations::performBsplineRegistrationDICOM for DICOM
            coordinates and original volume values.  
              
            
             </summary>
            
             <param name="settings">
            the deformable algorithm settings  
            
            </param>
            <returns>
            if successful  
            
            </returns>
        </member>
        <member name="M:RegistrationOperations.getErrorMessage">
             <summary>Returns the error message from the last operation or <c>""</c> if there is
            none.  
            
             </summary>
        </member>
        <member name="M:RegistrationOperations.getLocalizedErrorMessage">
             <summary>Returns the error message, localized by global language settings, from the last
            operation or <c>""</c> if there is none.  
            
             </summary>
        </member>
        <member name="M:RegistrationOperations.exportRegistration(System.Int32)">
             <summary>Creates a DICOM file for the published registration given by registrationId in
            the registrations table  
            
             </summary>
        </member>
        <member name="T:ReportOperations">
             <summary>Handles report operations without requiring any GUI.  
            
             </summary>
        </member>
        <member name="M:ReportOperations.#ctor(SWIGTYPE_p_vsc__Persistor,SWIGTYPE_p_vsc__Database)">
            <summary>
            </summary>
        </member>
        <member name="M:ReportOperations.attachRegistrationCommissioningToReport(System.Int32)">
             <summary>The following function will attach to the internal report the specified
            Registration Commissioning item which is evaluated against the currently loaded
            registration item. Note, a value of 'false' is returned if an error occurred
            (you can use the "getErrorMessage()" function to obtain the last error.  
            
             </summary>
        </member>
        <member name="M:ReportOperations.attachViewer3DToReport">
             <summary>The following function will attach the current Viewer state to the internal
            report. A value of 'true' is returned if the operation was successful.  
            
             </summary>
        </member>
        <member name="M:ReportOperations.appendToReport(SWIGTYPE_p_QString,System.Boolean)">
             <summary>The following function will append the specified html stream to the current
            internal HTML Report. Please note that if the 'includePatientHeaderInformation'
            variable is set to 'true' then a Patient Header Information will be added prior
            to the appending of the specified html stream to the internal report. A value of
            'true' is returned if the function is successful; otherwise a value of 'false'
            is returned and the "getErrorMessage()" function can be used to get the error
            occurred.  
            
             </summary>
        </member>
        <member name="M:ReportOperations.appendToReport(SWIGTYPE_p_QString)">
             <summary>The following function will append the specified html stream to the current
            internal HTML Report. Please note that if the 'includePatientHeaderInformation'
            variable is set to 'true' then a Patient Header Information will be added prior
            to the appending of the specified html stream to the internal report. A value of
            'true' is returned if the function is successful; otherwise a value of 'false'
            is returned and the "getErrorMessage()" function can be used to get the error
            occurred.  
            
             </summary>
        </member>
        <member name="M:ReportOperations.getReport">
             <summary>The following function will return the current internal HTML Report.  
            
             </summary>
        </member>
        <member name="M:ReportOperations.clearReport">
             <summary>The following function will clear the internal HTML Report.  
            
             </summary>
        </member>
        <member name="M:ReportOperations.saveReportToDatabase(System.String)">
             <summary>The following function will save the current internal HTML Report into the
            database (the specified 'reportName' will be used as the report name in the
            database record). Note, if the function is successful then the database record
            id of the newly added report record is returned; otherwise a value of '-1' is
            returned. Also note that the internal report is also cleared upon successfully
            being written into the database; if you wish to keep appending to a new copy of
            this report then you will need to load the last report record saved.  
            
             </summary>
        </member>
        <member name="M:ReportOperations.loadReportFromDatabase(System.Int32)">
             <summary>The following function will load the specified Report from the database.  
            
             </summary>
        </member>
        <member name="M:ReportOperations.persistCachedReport">
             <summary>The following function will persist the current internal HTML report into a
            temporary file (with extension "temp_vgr") within the database for the current
            patient. If the temporary file exists then it will be overwritten.  
            
             </summary>
        </member>
        <member name="M:ReportOperations.loadPersistentCachedReport">
             <summary>The following function will load any existing persistent report for this patient
            from the database and into the internal report of this class.  
            
             </summary>
        </member>
        <member name="M:ReportOperations.getErrorMessage">
            <summary>
            </summary>
        </member>
        <member name="M:ReportOperations.getLocalizedErrorMessage">
            <summary>
            </summary>
        </member>
        <member name="T:RigidRegistrationSettingsStructure">
             <summary>Automated rigid registration algorithm settings.  
            
            Attributes
            ----------
            * `performInitialAutoAlignment` : `bool`  
            
            * `disableRotationsX` : `bool`  
                Set to disable rotations in the X dimension.  
            
            * `disableRotationsY` : `bool`  
                Set to disable rotations in the Y dimension.  
            
            * `disableRotationsZ` : `bool`  
                Set to disable rotations in the Z dimension.  
            
            * `disableTranslationsX` : `bool`  
                Set to disable translation in the X dimension.  
            
            * `disableTranslationsY` : `bool`  
                Set to disable translation in the Y dimension.  
            
            * `disableTranslationsZ` : `bool`  
                Set to disable translation in the Z dimension.  
            
            * `maximumNumberOfIterations` : `int`  
                The maximum iterations allowed for the algorithm to converge.  
            
            * `maximumStepLength` : `double`  
                The largest step size per iteration.  
            
            * `minimumStepLength` : `double`  
                The smallest step size per iteration.  
            
            * `samplesDenominator` : `int`  
            
            * `numberOfHistogramBins` : `int`  
            
             </summary>
        </member>
        <member name="M:RigidRegistrationSettingsStructure.#ctor">
            <summary>
            </summary>
        </member>
        <member name="T:ScaledVolumeData">
             <summary>Raw image data for a volume. Users should check Volume::isValid to determine if
            this volume data is valid.  
            
            Attributes
            ----------
            * `volume` : `Volume`  
            
            * `data` : `std::vector&lt; double &gt;`  
            
            * `size` : `VectorR3i`  
            
            * `indexTransform` : `MatrixR44d`  
            
             </summary>
        </member>
        <member name="T:StringList.StringListEnumerator">
            Note that the IEnumerator documentation requires an InvalidOperationException to be thrown
            whenever the collection is modified. This has been done for changes in the size of the
            collection but not when one of the elements of the collection is modified as it is a bit
            tricky to detect unmanaged code that modifies the collection under our feet.
        </member>
        <member name="T:Structure">
            <summary>
            </summary>
        </member>
        <member name="M:Structure.isLocked">
            <summary>
            </summary>
        </member>
        <member name="M:Structure.getCreateDate">
             <summary>Returns the record creation date in ISO format.  
            
             </summary>
        </member>
        <member name="M:Structure.getEditDate">
             <summary>Returns the record edit date in ISO format.  
            
             </summary>
        </member>
        <member name="M:Structure.getName">
            <summary>
            </summary>
        </member>
        <member name="M:Structure.getInstanceUID">
            <summary>
            </summary>
        </member>
        <member name="M:Structure.getFrameOfReferenceUID">
            <summary>
            </summary>
        </member>
        <member name="M:Structure.getType">
            <summary>
            </summary>
        </member>
        <member name="M:Structure.isEditable">
            <summary>
            </summary>
        </member>
        <member name="M:Structure.getVolumetricSize">
            <summary>
            </summary>
        </member>
        <member name="M:Structure.getROINumber">
            <summary>
            </summary>
        </member>
        <member name="M:Structure.getVolume">
            <summary>
            </summary>
        </member>
        <member name="M:Structure.getVolumeId">
            <summary>
            </summary>
        </member>
        <member name="M:Structure.getStructureSet">
            <summary>
            </summary>
        </member>
        <member name="T:StructureGuidedRegistrationInformation">
             <summary>
            Attributes
            ----------
            * `structureGuidedMethod` : `StructureGuidedMethod`  
            
            * `primarySurfacePointsSCE` : `std::vector&lt; vsc::VectorR3d &gt;`  
            
            * `secondarySurfacePointsSCE` : `std::vector&lt; vsc::VectorR3d &gt;`  
            
            * `surfacePointsWeightCoefficients` : `std::vector&lt; double &gt;`  
            
            * `internalStructurePointsSCE` : `std::vector&lt; vsc::VectorR3d &gt;`  
            
            * `neighboringPointIndices` : `std::vector&lt; std::vector&lt; int &gt; &gt;`  
            
            * `burnInVolumeMember` : `SelectedVolumeMember`  
            
            * `burnInStructureVolume` : `vsc::ImageR3us *`  
            
            * `burnInVoxelValue` : `unsigned short`  
            
            * `euclideanDistanceMapOfStructure` : `vsc::EuclideanDistanceTransformR3 *`  
            
            * `euclideanDistanceMapModelTransform` : `vsc::AffineTransformR3d`  
            
            * `structureSurfacePointsSCE` : `std::vector&lt; vsc::VectorR3d &gt;`  
            
            * `structureWeightCoefficient` : `double`  
            
            * `handleObjectCleanup` : `bool`  
            
             </summary>
        </member>
        <member name="M:StructureGuidedRegistrationInformation.#ctor">
            <summary>
            </summary>
        </member>
        <member name="T:StructureList.StructureListEnumerator">
            Note that the IEnumerator documentation requires an InvalidOperationException to be thrown
            whenever the collection is modified. This has been done for changes in the size of the
            collection but not when one of the elements of the collection is modified as it is a bit
            tricky to detect unmanaged code that modifies the collection under our feet.
        </member>
        <member name="T:StructureMap.StructureMapEnumerator">
            Note that the IEnumerator documentation requires an InvalidOperationException to be thrown
            whenever the collection is modified. This has been done for changes in the size of the
            collection but not when one of the elements of the collection is modified as it is a bit
            tricky to detect unmanaged code that modifies the collection under our feet.
        </member>
        <member name="T:StructureMask">
             <summary>
            Attributes
            ----------
            * `data` : `std::vector&lt; bool &gt;`  
            
            * `size` : `VectorR3i`  
            
             </summary>
        </member>
        <member name="M:StructureMask.#ctor">
            <summary>
            </summary>
        </member>
        <member name="M:StructureMask.#ctor(VectorR3i)">
            <summary>
            </summary>
        </member>
        <member name="M:StructureMask.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="T:StructureOperations">
             <summary>Handles structure operations without requiring any GUI.  
            
             </summary>
        </member>
        <member name="M:StructureOperations.#ctor(SWIGTYPE_p_vsc__Persistor,SWIGTYPE_p_vsc__Database)">
            <summary>
            </summary>
        </member>
        <member name="M:StructureOperations.createStructure(System.Int32,System.String,System.String,SWIGTYPE_p_vsc__Color)">
             <summary>Creates a new structure.  
            The type should be a valid DICOM type. If you are creating a structure for the
            result of a structure operation, copy the type from the source structure.  
              
            
             </summary>
            
             <param name="structureSetId">
            the strucrure set of the new structure  
            
            </param>
            
            
             <param name="name">
            the structure name  
            
            </param>
            
            
             <param name="type">
            the DICOM type of the structure  
            
            </param>
            
            
             <param name="color">
            an optional color, otherwise one is chosen automatically @  
            
            </param>
        </member>
        <member name="M:StructureOperations.createStructure(System.Int32,System.String,System.String)">
             <summary>Creates a new structure.  
            The type should be a valid DICOM type. If you are creating a structure for the
            result of a structure operation, copy the type from the source structure.  
              
            
             </summary>
            
             <param name="structureSetId">
            the strucrure set of the new structure  
            
            </param>
            
            
             <param name="name">
            the structure name  
            
            </param>
            
            
             <param name="type">
            the DICOM type of the structure  
            
            </param>
            
            
             <param name="color">
            an optional color, otherwise one is chosen automatically @  
            
            </param>
        </member>
        <member name="M:StructureOperations.createStructure(System.Int32,System.String)">
             <summary>Creates a new structure.  
            The type should be a valid DICOM type. If you are creating a structure for the
            result of a structure operation, copy the type from the source structure.  
              
            
             </summary>
            
             <param name="structureSetId">
            the strucrure set of the new structure  
            
            </param>
            
            
             <param name="name">
            the structure name  
            
            </param>
            
            
             <param name="type">
            the DICOM type of the structure  
            
            </param>
            
            
             <param name="color">
            an optional color, otherwise one is chosen automatically @  
            
            </param>
        </member>
        <member name="M:StructureOperations.createStructureSet(System.String,System.Boolean,System.String,System.String)">
             <summary>Creates a new structure set.  
              
            
             </summary>
            
             <param name="name">
            the name of the new structure set  
            
            </param>
            
            
             <param name="onPrimary">
            create on the primary volume if true, on the secondary otherwise  
            
            </param>
            
            
             <param name="studyUID">
            optional, specify the study UID, otherwise one will be generated  
            
            </param>
            
            
             <param name="studyDate">
            optional, specify the study date in ISO 8601 format, otherwise the current date
            
            will be used  
            
            </param>
            <returns>
            the created structure set (invalid on error)  
            
            </returns>
        </member>
        <member name="M:StructureOperations.createStructureSet(System.String,System.Boolean,System.String)">
             <summary>Creates a new structure set.  
              
            
             </summary>
            
             <param name="name">
            the name of the new structure set  
            
            </param>
            
            
             <param name="onPrimary">
            create on the primary volume if true, on the secondary otherwise  
            
            </param>
            
            
             <param name="studyUID">
            optional, specify the study UID, otherwise one will be generated  
            
            </param>
            
            
             <param name="studyDate">
            optional, specify the study date in ISO 8601 format, otherwise the current date
            
            will be used  
            
            </param>
            <returns>
            the created structure set (invalid on error)  
            
            </returns>
        </member>
        <member name="M:StructureOperations.createStructureSet(System.String,System.Boolean)">
             <summary>Creates a new structure set.  
              
            
             </summary>
            
             <param name="name">
            the name of the new structure set  
            
            </param>
            
            
             <param name="onPrimary">
            create on the primary volume if true, on the secondary otherwise  
            
            </param>
            
            
             <param name="studyUID">
            optional, specify the study UID, otherwise one will be generated  
            
            </param>
            
            
             <param name="studyDate">
            optional, specify the study date in ISO 8601 format, otherwise the current date
            
            will be used  
            
            </param>
            <returns>
            the created structure set (invalid on error)  
            
            </returns>
        </member>
        <member name="M:StructureOperations.createStructureSet(System.String)">
             <summary>Creates a new structure set.  
              
            
             </summary>
            
             <param name="name">
            the name of the new structure set  
            
            </param>
            
            
             <param name="onPrimary">
            create on the primary volume if true, on the secondary otherwise  
            
            </param>
            
            
             <param name="studyUID">
            optional, specify the study UID, otherwise one will be generated  
            
            </param>
            
            
             <param name="studyDate">
            optional, specify the study date in ISO 8601 format, otherwise the current date
            
            will be used  
            
            </param>
            <returns>
            the created structure set (invalid on error)  
            
            </returns>
        </member>
        <member name="M:StructureOperations.saveStructureSet(System.Int32,System.String)">
             <summary>Saves changes to a structure set.  
            You must call this function after finishing a set of modifications to a
            structure set.  
            This increases the version number and changes the name and UID accordingly. Any
            existing DICOM RTSTRUCT file will be removed and a new one generated as if by
            calling StructureOperations::exportStructureSet.  
            You should use the return value of this function rather than an existing handle
            on this structure set as the old handle will have stale attributes (e.g. UID).  
              
            
             </summary>
            
             <param name="structureSetId">
            the velocity Id of the structure set  
            
            </param>
            
            
             <param name="encodingType">
            optional encoding type  
            
            </param>
            <returns>
            the updated structure set, or an invalid one on error  
            
            </returns>
        </member>
        <member name="M:StructureOperations.saveStructureSet(System.Int32)">
             <summary>Saves changes to a structure set.  
            You must call this function after finishing a set of modifications to a
            structure set.  
            This increases the version number and changes the name and UID accordingly. Any
            existing DICOM RTSTRUCT file will be removed and a new one generated as if by
            calling StructureOperations::exportStructureSet.  
            You should use the return value of this function rather than an existing handle
            on this structure set as the old handle will have stale attributes (e.g. UID).  
              
            
             </summary>
            
             <param name="structureSetId">
            the velocity Id of the structure set  
            
            </param>
            
            
             <param name="encodingType">
            optional encoding type  
            
            </param>
            <returns>
            the updated structure set, or an invalid one on error  
            
            </returns>
        </member>
        <member name="M:StructureOperations.exportStructureSet(System.Int32,System.String)">
             <summary>Creates the physical RTSTRUCT DICOM file on disk.  
            The structure set id must be linked to an existing StructureSet record and
            associated structure records. The file is created based on the database records
            as they exist at call time.  
              
            
             </summary>
            
             <param name="structureSetId">
            the velocity Id of the structure set  
            
            </param>
            
            
             <param name="encodingType">
            optional encoding type  
            
            </param>
        </member>
        <member name="M:StructureOperations.exportStructureSet(System.Int32)">
             <summary>Creates the physical RTSTRUCT DICOM file on disk.  
            The structure set id must be linked to an existing StructureSet record and
            associated structure records. The file is created based on the database records
            as they exist at call time.  
              
            
             </summary>
            
             <param name="structureSetId">
            the velocity Id of the structure set  
            
            </param>
            
            
             <param name="encodingType">
            optional encoding type  
            
            </param>
        </member>
        <member name="M:StructureOperations.copyStructuresToSecondary(IntList,System.Int32)">
             <summary>Copy structures from the primary volume to the secondary volume, using the
            currently loaded registration.  
              
            
             </summary>
            
             <param name="primaryStructureIds">
            the internal ids of the structures to copy  
            
            </param>
            
            
             <param name="structureSetId">
            the internal id of the target structure set (must be associated with the
            
            secondary volume)  
            
            </param>
            <returns>
            the newly created structures, mapped by the source structure id  
            
            </returns>
        </member>
        <member name="M:StructureOperations.copyStructuresToPrimary(IntList,System.Int32)">
             <summary>Copy structures from the secondary volume to the primary volume, using the
            currently loaded registration.  
              
            
             </summary>
            
             <param name="secondaryStructureIds">
            the internal ids of the structures to copy  
            
            </param>
            
            
             <param name="structureSetId">
            the internal id of the target structure set (must be associated with the primary
            
            volume)  
            
            </param>
            <returns>
            the newly created structures, mapped by the source structure id  
            
            </returns>
        </member>
        <member name="M:StructureOperations.getVolumetricStructure(System.Int32)">
             <summary>Retrieves the structure data as a mask.  
            The structure must belong to the current primary or secondary volume. The
            resulting mask data will always be in the space of the primary volume. If the
            structure belongs to the primary volume, it will be returned as is, but if it
            belongs to the secondary volume then it will first placed in the primary space
            using the current registration and the result will reflect that transformation.  
            
             </summary>
        </member>
        <member name="M:StructureOperations.createStructureFromMask(System.Int32,StructureMask,System.String,System.String,SWIGTYPE_p_vsc__Color)">
             <summary>Given a binary mask it convers it into a structure.  
            The structure must belong to the current primary volume. The dimensions of the
            mask must be the same as the primary volume. The frame of reference and index
            transform of the structure will be taken from the primary volume.  
              
            
             </summary>
            
             <param name="structureSetId">
            the strucrure set of the new structure  
            
            </param>
            
            
             <param name="mask">
            mask.data is be the binary mask used to create the structure  
            
            </param>
            
            
             <param name="name">
            the structure name  
            
            </param>
            
            
             <param name="type">
            the DICOM type of the structure  
            
            </param>
            
            
             <param name="color">
            an optional color, otherwise one is chosen automatically  
            
            </param>
        </member>
        <member name="M:StructureOperations.createStructureFromMask(System.Int32,StructureMask,System.String,System.String)">
             <summary>Given a binary mask it convers it into a structure.  
            The structure must belong to the current primary volume. The dimensions of the
            mask must be the same as the primary volume. The frame of reference and index
            transform of the structure will be taken from the primary volume.  
              
            
             </summary>
            
             <param name="structureSetId">
            the strucrure set of the new structure  
            
            </param>
            
            
             <param name="mask">
            mask.data is be the binary mask used to create the structure  
            
            </param>
            
            
             <param name="name">
            the structure name  
            
            </param>
            
            
             <param name="type">
            the DICOM type of the structure  
            
            </param>
            
            
             <param name="color">
            an optional color, otherwise one is chosen automatically  
            
            </param>
        </member>
        <member name="M:StructureOperations.createStructureFromMask(System.Int32,StructureMask,System.String)">
             <summary>Given a binary mask it convers it into a structure.  
            The structure must belong to the current primary volume. The dimensions of the
            mask must be the same as the primary volume. The frame of reference and index
            transform of the structure will be taken from the primary volume.  
              
            
             </summary>
            
             <param name="structureSetId">
            the strucrure set of the new structure  
            
            </param>
            
            
             <param name="mask">
            mask.data is be the binary mask used to create the structure  
            
            </param>
            
            
             <param name="name">
            the structure name  
            
            </param>
            
            
             <param name="type">
            the DICOM type of the structure  
            
            </param>
            
            
             <param name="color">
            an optional color, otherwise one is chosen automatically  
            
            </param>
        </member>
        <member name="M:StructureOperations.createStructureFromMask(System.Int32,StructureMask)">
             <summary>Given a binary mask it convers it into a structure.  
            The structure must belong to the current primary volume. The dimensions of the
            mask must be the same as the primary volume. The frame of reference and index
            transform of the structure will be taken from the primary volume.  
              
            
             </summary>
            
             <param name="structureSetId">
            the strucrure set of the new structure  
            
            </param>
            
            
             <param name="mask">
            mask.data is be the binary mask used to create the structure  
            
            </param>
            
            
             <param name="name">
            the structure name  
            
            </param>
            
            
             <param name="type">
            the DICOM type of the structure  
            
            </param>
            
            
             <param name="color">
            an optional color, otherwise one is chosen automatically  
            
            </param>
        </member>
        <member name="M:StructureOperations.surfaceDistanceMetrics(System.Int32,System.Int32)">
             <summary>Computes the surface distance metrics between two structures. Check the
            SurfaceDistanceMetrics::isValid flag to determine if there was an error, and
            StructureOperations::getErrorMessage to get the error.  
            
             </summary>
        </member>
        <member name="M:StructureOperations.conformality(System.Int32,System.Int32)">
             <summary>Computes the conformality between two structures. The structures must be
            associated with the currently loaded primary or secondary volumes.  
            
             </summary>
        </member>
        <member name="M:StructureOperations.margin(System.Int32,System.Int32,System.Int32,MarginSettings)">
             <summary>Applies a margin operation to a structure and stores the result in an existing
            structure.  
            The target structure can be the same as the source structure or another existing
            structure.  
              
            
             </summary>
            
             <param name="sourceId">
            the source structure's Velocity id  
            
            </param>
            
            
             <param name="targetId">
            the target structure's Velocity id  
            
            </param>
            
            
             <param name="settings">
            the margin parameters to apply  
            
            </param>
            <returns>
            the target structure info or an invalid structure on error  
            
            </returns>
        </member>
        <member name="M:StructureOperations.unionStructures(System.Int32,IntList,System.String,SWIGTYPE_p_vsc__Color)">
             <summary>Creates a new structure from the union of multiple structures.  
              
            
             </summary>
            
             <param name="structureSetId">
            the velocity id of the structure set where the target structure will be created  
            
            </param>
            
            
             <param name="structureIds">
            the Velocity ids of the structures to union, must have at least one element  
            
            </param>
            
            
             <param name="targetName">
            the name of the new structure  
            
            </param>
            
            
             <param name="targetColor">
            an optional color for the new structure, otherwise one is chosen automatically  
            
            </param>
            <returns>
            the target structure info or an invalid structure on error  
            
            </returns>
        </member>
        <member name="M:StructureOperations.unionStructures(System.Int32,IntList,System.String)">
             <summary>Creates a new structure from the union of multiple structures.  
              
            
             </summary>
            
             <param name="structureSetId">
            the velocity id of the structure set where the target structure will be created  
            
            </param>
            
            
             <param name="structureIds">
            the Velocity ids of the structures to union, must have at least one element  
            
            </param>
            
            
             <param name="targetName">
            the name of the new structure  
            
            </param>
            
            
             <param name="targetColor">
            an optional color for the new structure, otherwise one is chosen automatically  
            
            </param>
            <returns>
            the target structure info or an invalid structure on error  
            
            </returns>
        </member>
        <member name="M:StructureOperations.intersectStructures(System.Int32,IntList,System.String,SWIGTYPE_p_vsc__Color)">
             <summary>Creates a new structure from the intersection of multiple structures.  
              
            
             </summary>
            
             <param name="structureSetId">
            the velocity id of the structure set where the target structure will be created  
            
            </param>
            
            
             <param name="targetId">
            the Velocity id of the target structure to store the result in  
            
            </param>
            
            
             <param name="structureIds">
            the Velocity ids of the structures to intersect, must have at least one element  
            
            </param>
            <returns>
            the target structure info or an invalid structure on error  
            
            </returns>
        </member>
        <member name="M:StructureOperations.intersectStructures(System.Int32,IntList,System.String)">
             <summary>Creates a new structure from the intersection of multiple structures.  
              
            
             </summary>
            
             <param name="structureSetId">
            the velocity id of the structure set where the target structure will be created  
            
            </param>
            
            
             <param name="targetId">
            the Velocity id of the target structure to store the result in  
            
            </param>
            
            
             <param name="structureIds">
            the Velocity ids of the structures to intersect, must have at least one element  
            
            </param>
            <returns>
            the target structure info or an invalid structure on error  
            
            </returns>
        </member>
        <member name="M:StructureOperations.smooth(System.Int32,System.Int32,System.String)">
             <summary>Smooth a structure, creating a new structure.  
            
             </summary>
            
             <param name="structureSetId">
            the velocity id of the structure set where the target structure will be created  
            
            </param>
            
            
             <param name="structureId">
            the velocity id of the source structure  
            
            </param>
            
            
             <param name="targetName">
            the name of the new structure  
            
            </param>
            <returns>
            the target structure info or an invalid structure on error  
            
            </returns>
        </member>
        <member name="M:StructureOperations.crop(System.Int32,System.Int32,IntList,CropSettings,System.String,SWIGTYPE_p_vsc__Color)">
             <summary>Crops a structure using a set of other structures.  
              
            
             </summary>
            
             <param name="structureSetId">
            the velocity id of the structure set where the target structure will be created  
            
            </param>
            
            
             <param name="sourceStructureId">
            the structure to be cropped  
            
            </param>
            
            
             <param name="croppingStructureIds">
            the structures used to crop the source  
            
            </param>
            
            
             <param name="cropSettings">
            parameters for cropping  
            
            </param>
            
            
             <param name="targetName">
            the name of the new structure  
            
            </param>
            
            
             <param name="targetColor">
            optional color for the new structure  
            
            </param>
            <returns>
            the target structure info or an invalid structure on error  
            
            </returns>
        </member>
        <member name="M:StructureOperations.crop(System.Int32,System.Int32,IntList,CropSettings,System.String)">
             <summary>Crops a structure using a set of other structures.  
              
            
             </summary>
            
             <param name="structureSetId">
            the velocity id of the structure set where the target structure will be created  
            
            </param>
            
            
             <param name="sourceStructureId">
            the structure to be cropped  
            
            </param>
            
            
             <param name="croppingStructureIds">
            the structures used to crop the source  
            
            </param>
            
            
             <param name="cropSettings">
            parameters for cropping  
            
            </param>
            
            
             <param name="targetName">
            the name of the new structure  
            
            </param>
            
            
             <param name="targetColor">
            optional color for the new structure  
            
            </param>
            <returns>
            the target structure info or an invalid structure on error  
            
            </returns>
        </member>
        <member name="M:StructureOperations.getStructureHistogram(System.Int32,System.Boolean,System.UInt16)">
             <summary>Computes and returns the Volume Histogram of a structure.  
            pre: the patient volume is loaded as primary or as secondary volume  
              
            
             </summary>
            
             <param name="structureId">
            id of the structure to compute the histogram of  
            
            </param>
            
            
             <param name="onPrimary">
            histogram will be created on the primary volume if true, on the secondary
            
            otherwise  
            
            </param>
            
            
             <param name="bins">
            the number of histogram bins to compute  
            
            </param>
            <returns>
            a pair with the first slot indicating success or failure and second containing
            
            the histogram values  
            
            </returns>
        </member>
        <member name="M:StructureOperations.getStructureHistogram(System.Int32,System.Boolean)">
             <summary>Computes and returns the Volume Histogram of a structure.  
            pre: the patient volume is loaded as primary or as secondary volume  
              
            
             </summary>
            
             <param name="structureId">
            id of the structure to compute the histogram of  
            
            </param>
            
            
             <param name="onPrimary">
            histogram will be created on the primary volume if true, on the secondary
            
            otherwise  
            
            </param>
            
            
             <param name="bins">
            the number of histogram bins to compute  
            
            </param>
            <returns>
            a pair with the first slot indicating success or failure and second containing
            
            the histogram values  
            
            </returns>
        </member>
        <member name="M:StructureOperations.getStructureHistogram(System.Int32)">
             <summary>Computes and returns the Volume Histogram of a structure.  
            pre: the patient volume is loaded as primary or as secondary volume  
              
            
             </summary>
            
             <param name="structureId">
            id of the structure to compute the histogram of  
            
            </param>
            
            
             <param name="onPrimary">
            histogram will be created on the primary volume if true, on the secondary
            
            otherwise  
            
            </param>
            
            
             <param name="bins">
            the number of histogram bins to compute  
            
            </param>
            <returns>
            a pair with the first slot indicating success or failure and second containing
            
            the histogram values  
            
            </returns>
        </member>
        <member name="M:StructureOperations.getErrorMessage">
             <summary>Returns the error message from the last operation or <c>""</c> if there is
            none.  
            
             </summary>
        </member>
        <member name="M:StructureOperations.getLocalizedErrorMessage">
             <summary>Returns the error message, localized by global language settings, from the last
            operation or <c>""</c> if there is none.  
            
             </summary>
        </member>
        <member name="T:StructureSet">
            <summary>
            </summary>
        </member>
        <member name="M:StructureSet.isLocked">
            <summary>
            </summary>
        </member>
        <member name="M:StructureSet.getCreateDate">
             <summary>Returns the record creation date in ISO format.  
            
             </summary>
        </member>
        <member name="M:StructureSet.getEditDate">
             <summary>Returns the record edit date in ISO format.  
            
             </summary>
        </member>
        <member name="M:StructureSet.getName">
            <summary>
            </summary>
        </member>
        <member name="M:StructureSet.getSeriesDescription">
            <summary>
            </summary>
        </member>
        <member name="M:StructureSet.getInstanceUID">
            <summary>
            </summary>
        </member>
        <member name="M:StructureSet.getStudyUID">
            <summary>
            </summary>
        </member>
        <member name="M:StructureSet.getSeriesUID">
            <summary>
            </summary>
        </member>
        <member name="M:StructureSet.getStudyDate">
             <summary>Returns the study date in ISO format.  
            
             </summary>
        </member>
        <member name="M:StructureSet.getVolume">
            <summary>
            </summary>
        </member>
        <member name="M:StructureSet.getVolumeUID">
            <summary>
            </summary>
        </member>
        <member name="M:StructureSet.getStructures">
            <summary>
            </summary>
        </member>
        <member name="T:StructureSetList.StructureSetListEnumerator">
            Note that the IEnumerator documentation requires an InvalidOperationException to be thrown
            whenever the collection is modified. This has been done for changes in the size of the
            collection but not when one of the elements of the collection is modified as it is a bit
            tricky to detect unmanaged code that modifies the collection under our feet.
        </member>
        <member name="T:SurfaceDistanceMetrics">
             <summary>The surface distance metrics between two structures. In addition to the standard
            Hausdorff distance, several additional metrics are provided. All units are in
            millimeters (mm). For error cases, <c>isValid</c> will be <c>false</c> and the
            values of the other metrics are undefined.  
            
            Attributes
            ----------
            * `isValid` : `bool`  
            
            * `hausdorffDistance` : `double`  
            
            * `min` : `double`  
            
            * `mean` : `double`  
            
            * `median` : `double`  
            
            * `standardDeviation` : `double`  
            
            * `structureName1` : `std::string`  
            
            * `structureName2` : `std::string`  
            
             </summary>
        </member>
        <member name="M:SurfaceDistanceMetrics.#ctor">
            <summary>
            </summary>
        </member>
        <member name="T:TransformedRegistrationMarker">
             <summary>A registration marker as in vsc::patientdata::RegistrationMarker that also
            includes transformed locations according to a registration.  
            
            Attributes
            ----------
            * `primaryInIndex` : `VectorR3d`  
            
            * `secondaryInIndex` : `VectorR3d`  
            
            * `primaryInScene` : `VectorR3d`  
            
            * `deformedSecondaryInScene` : `VectorR3d`  
            
            * `primaryInPrimaryDICOM` : `VectorR3d`  
            
            * `deformedSecondaryInPrimaryDICOM` : `VectorR3d`  
            
            * `rigidSecondaryInPrimaryDICOM` : `VectorR3d`  
            
            * `deformedSecondaryInSecondaryDICOM` : `VectorR3d`  
            
            * `rigidSecondaryInSecondaryDICOM` : `VectorR3d`  
            
            * `name` : `std::string`  
            
            * `isConfirmed` : `bool`  
            
             </summary>
        </member>
        <member name="T:VectorR2b">
             <summary>The VectorR template class represents fixed-size, real vectors. The size of the
            vector and the element type are specified as part of the type, and are thus
            fixed at compile time. This vector class represents both positional vectors
            representing points, and covariance vectors such as normal and tangent vectors.  
            *N* is the number of elements, which must be greater than zero. *E* is the
            element type, typically <c>double</c>, <c>float</c>, or <c>int</c>.  
            
            Attributes
            ----------
            * `SIZE` : `const unsigned int`  
                The number of elements in vectors of this type.  
            
             </summary>
        </member>
        <member name="M:VectorR2b.#ctor(System.Collections.Generic.ICollection{System.Char})">
            <summary>Construct a VectorR2b from a collection of values.</summary>
            <remarks><code>values</code> must have size 2.</remarks>
            <exception cref="T:System.ArgumentException">If <code>values</code> is not size 2.</exception>
        </member>
        <member name="M:VectorR2b.#ctor(System.Char[])">
            <summary>Construct a VectorR2b from a collection of values.</summary>
            <remarks>2 parameters must be given.</remarks>
            <exception cref="T:System.ArgumentException">If exactly 2 parameters are not given.</exception>
        </member>
        <member name="M:VectorR2b.#ctor">
             <summary>Constructs a copy of *v*.  
            
             </summary>
        </member>
        <member name="M:VectorR2b.#ctor(System.Char)">
             <summary>Constructs a copy of *v*.  
            
             </summary>
        </member>
        <member name="M:VectorR2b.#ctor(System.String)">
             <summary>Constructs a copy of *v*.  
            
             </summary>
        </member>
        <member name="M:VectorR2b.#ctor(VectorR2b)">
             <summary>Constructs a copy of *v*.  
            
             </summary>
        </member>
        <member name="M:VectorR2b.set(System.Char)">
             <summary>Sets all elements of this vector to *element*.  
            
             </summary>
        </member>
        <member name="M:VectorR2b.setElements(System.String)">
             <summary>Copies the elements from *elementArray* to this vector. The array must contain
            *N* elements.  
            
             </summary>
        </member>
        <member name="M:VectorR2b.nonNegative">
             <summary>Returns true if every element of this vector is nonnegative.  
            
             </summary>
        </member>
        <member name="M:VectorR2b.positive">
             <summary>Returns true if every element of this vector is strictly positive.  
            
             </summary>
        </member>
        <member name="M:VectorR2b.size">
            <summary>
            </summary>
        </member>
        <member name="M:VectorR2b.xy">
             <summary>Similar to the OpenGL in shader function that returns the first 2 components of
            a vector. Components that are not defined are defaulted to zero.    note: In
            C++11 compilers, the return is optimized by copy ellision, so actual
                copies take place. See NRVO  
              
            
             </summary>
        </member>
        <member name="M:VectorR2b.xyz">
             <summary>Similar to the opengl in shader function that returns the first 3 components of
            a vector. Components that are not defined are defaulted to zero.    note: In
            C++11 compilers, the return is optimized by copy ellision, so actual
                copies take place. See NRVO  
              
            
             </summary>
        </member>
        <member name="M:VectorR2b.xyzw">
             <summary>Similar to the opengl in shader function that returns the first 3 components of
            a vector. Components that are not defined are defaulted to zero. An undefined W
            coordinate is defaulted to 1.    note: In C++11 compilers, the return is
            optimized by copy ellision, so actual
                copies take place. See NRVO  
              
            
             </summary>
        </member>
        <member name="M:VectorR2b.normalized(System.Double)">
             <summary>Convenience function that uses the vsc::normalize function to return the
            normalized vector  
            
             </summary>
        </member>
        <member name="M:VectorR2b.normalized">
             <summary>Convenience function that uses the vsc::normalize function to return the
            normalized vector  
            
             </summary>
        </member>
        <member name="T:VectorR2bList.VectorR2bListEnumerator">
            Note that the IEnumerator documentation requires an InvalidOperationException to be thrown
            whenever the collection is modified. This has been done for changes in the size of the
            collection but not when one of the elements of the collection is modified as it is a bit
            tricky to detect unmanaged code that modifies the collection under our feet.
        </member>
        <member name="T:VectorR2d">
             <summary>The VectorR template class represents fixed-size, real vectors. The size of the
            vector and the element type are specified as part of the type, and are thus
            fixed at compile time. This vector class represents both positional vectors
            representing points, and covariance vectors such as normal and tangent vectors.  
            *N* is the number of elements, which must be greater than zero. *E* is the
            element type, typically <c>double</c>, <c>float</c>, or <c>int</c>.  
            
            Attributes
            ----------
            * `SIZE` : `const unsigned int`  
                The number of elements in vectors of this type.  
            
             </summary>
        </member>
        <member name="M:VectorR2d.#ctor(System.Collections.Generic.ICollection{System.Double})">
            <summary>Construct a VectorR2d from a collection of values.</summary>
            <remarks><code>values</code> must have size 2.</remarks>
            <exception cref="T:System.ArgumentException">If <code>values</code> is not size 2.</exception>
        </member>
        <member name="M:VectorR2d.#ctor(System.Double[])">
            <summary>Construct a VectorR2d from a collection of values.</summary>
            <remarks>2 parameters must be given.</remarks>
            <exception cref="T:System.ArgumentException">If exactly 2 parameters are not given.</exception>
        </member>
        <member name="M:VectorR2d.#ctor">
             <summary>Constructs a copy of *v*.  
            
             </summary>
        </member>
        <member name="M:VectorR2d.#ctor(System.Double)">
             <summary>Constructs a copy of *v*.  
            
             </summary>
        </member>
        <member name="M:VectorR2d.#ctor(SWIGTYPE_p_double)">
             <summary>Constructs a copy of *v*.  
            
             </summary>
        </member>
        <member name="M:VectorR2d.#ctor(VectorR2d)">
             <summary>Constructs a copy of *v*.  
            
             </summary>
        </member>
        <member name="M:VectorR2d.set(System.Double)">
             <summary>Sets all elements of this vector to *element*.  
            
             </summary>
        </member>
        <member name="M:VectorR2d.setElements(SWIGTYPE_p_double)">
             <summary>Copies the elements from *elementArray* to this vector. The array must contain
            *N* elements.  
            
             </summary>
        </member>
        <member name="M:VectorR2d.nonNegative">
             <summary>Returns true if every element of this vector is nonnegative.  
            
             </summary>
        </member>
        <member name="M:VectorR2d.positive">
             <summary>Returns true if every element of this vector is strictly positive.  
            
             </summary>
        </member>
        <member name="M:VectorR2d.size">
            <summary>
            </summary>
        </member>
        <member name="M:VectorR2d.xy">
             <summary>Similar to the OpenGL in shader function that returns the first 2 components of
            a vector. Components that are not defined are defaulted to zero.    note: In
            C++11 compilers, the return is optimized by copy ellision, so actual
                copies take place. See NRVO  
              
            
             </summary>
        </member>
        <member name="M:VectorR2d.xyz">
             <summary>Similar to the opengl in shader function that returns the first 3 components of
            a vector. Components that are not defined are defaulted to zero.    note: In
            C++11 compilers, the return is optimized by copy ellision, so actual
                copies take place. See NRVO  
              
            
             </summary>
        </member>
        <member name="M:VectorR2d.xyzw">
             <summary>Similar to the opengl in shader function that returns the first 3 components of
            a vector. Components that are not defined are defaulted to zero. An undefined W
            coordinate is defaulted to 1.    note: In C++11 compilers, the return is
            optimized by copy ellision, so actual
                copies take place. See NRVO  
              
            
             </summary>
        </member>
        <member name="M:VectorR2d.normalized(System.Double)">
             <summary>Convenience function that uses the vsc::normalize function to return the
            normalized vector  
            
             </summary>
        </member>
        <member name="M:VectorR2d.normalized">
             <summary>Convenience function that uses the vsc::normalize function to return the
            normalized vector  
            
             </summary>
        </member>
        <member name="T:VectorR2dList.VectorR2dListEnumerator">
            Note that the IEnumerator documentation requires an InvalidOperationException to be thrown
            whenever the collection is modified. This has been done for changes in the size of the
            collection but not when one of the elements of the collection is modified as it is a bit
            tricky to detect unmanaged code that modifies the collection under our feet.
        </member>
        <member name="T:VectorR2f">
             <summary>The VectorR template class represents fixed-size, real vectors. The size of the
            vector and the element type are specified as part of the type, and are thus
            fixed at compile time. This vector class represents both positional vectors
            representing points, and covariance vectors such as normal and tangent vectors.  
            *N* is the number of elements, which must be greater than zero. *E* is the
            element type, typically <c>double</c>, <c>float</c>, or <c>int</c>.  
            
            Attributes
            ----------
            * `SIZE` : `const unsigned int`  
                The number of elements in vectors of this type.  
            
             </summary>
        </member>
        <member name="M:VectorR2f.#ctor(System.Collections.Generic.ICollection{System.Single})">
            <summary>Construct a VectorR2f from a collection of values.</summary>
            <remarks><code>values</code> must have size 2.</remarks>
            <exception cref="T:System.ArgumentException">If <code>values</code> is not size 2.</exception>
        </member>
        <member name="M:VectorR2f.#ctor(System.Single[])">
            <summary>Construct a VectorR2f from a collection of values.</summary>
            <remarks>2 parameters must be given.</remarks>
            <exception cref="T:System.ArgumentException">If exactly 2 parameters are not given.</exception>
        </member>
        <member name="M:VectorR2f.#ctor">
             <summary>Constructs a copy of *v*.  
            
             </summary>
        </member>
        <member name="M:VectorR2f.#ctor(System.Single)">
             <summary>Constructs a copy of *v*.  
            
             </summary>
        </member>
        <member name="M:VectorR2f.#ctor(SWIGTYPE_p_float)">
             <summary>Constructs a copy of *v*.  
            
             </summary>
        </member>
        <member name="M:VectorR2f.#ctor(VectorR2f)">
             <summary>Constructs a copy of *v*.  
            
             </summary>
        </member>
        <member name="M:VectorR2f.set(System.Single)">
             <summary>Sets all elements of this vector to *element*.  
            
             </summary>
        </member>
        <member name="M:VectorR2f.setElements(SWIGTYPE_p_float)">
             <summary>Copies the elements from *elementArray* to this vector. The array must contain
            *N* elements.  
            
             </summary>
        </member>
        <member name="M:VectorR2f.nonNegative">
             <summary>Returns true if every element of this vector is nonnegative.  
            
             </summary>
        </member>
        <member name="M:VectorR2f.positive">
             <summary>Returns true if every element of this vector is strictly positive.  
            
             </summary>
        </member>
        <member name="M:VectorR2f.size">
            <summary>
            </summary>
        </member>
        <member name="M:VectorR2f.xy">
             <summary>Similar to the OpenGL in shader function that returns the first 2 components of
            a vector. Components that are not defined are defaulted to zero.    note: In
            C++11 compilers, the return is optimized by copy ellision, so actual
                copies take place. See NRVO  
              
            
             </summary>
        </member>
        <member name="M:VectorR2f.xyz">
             <summary>Similar to the opengl in shader function that returns the first 3 components of
            a vector. Components that are not defined are defaulted to zero.    note: In
            C++11 compilers, the return is optimized by copy ellision, so actual
                copies take place. See NRVO  
              
            
             </summary>
        </member>
        <member name="M:VectorR2f.xyzw">
             <summary>Similar to the opengl in shader function that returns the first 3 components of
            a vector. Components that are not defined are defaulted to zero. An undefined W
            coordinate is defaulted to 1.    note: In C++11 compilers, the return is
            optimized by copy ellision, so actual
                copies take place. See NRVO  
              
            
             </summary>
        </member>
        <member name="M:VectorR2f.normalized(System.Double)">
             <summary>Convenience function that uses the vsc::normalize function to return the
            normalized vector  
            
             </summary>
        </member>
        <member name="M:VectorR2f.normalized">
             <summary>Convenience function that uses the vsc::normalize function to return the
            normalized vector  
            
             </summary>
        </member>
        <member name="T:VectorR2fList.VectorR2fListEnumerator">
            Note that the IEnumerator documentation requires an InvalidOperationException to be thrown
            whenever the collection is modified. This has been done for changes in the size of the
            collection but not when one of the elements of the collection is modified as it is a bit
            tricky to detect unmanaged code that modifies the collection under our feet.
        </member>
        <member name="T:VectorR2i">
             <summary>The VectorR template class represents fixed-size, real vectors. The size of the
            vector and the element type are specified as part of the type, and are thus
            fixed at compile time. This vector class represents both positional vectors
            representing points, and covariance vectors such as normal and tangent vectors.  
            *N* is the number of elements, which must be greater than zero. *E* is the
            element type, typically <c>double</c>, <c>float</c>, or <c>int</c>.  
            
            Attributes
            ----------
            * `SIZE` : `const unsigned int`  
                The number of elements in vectors of this type.  
            
             </summary>
        </member>
        <member name="M:VectorR2i.#ctor(System.Collections.Generic.ICollection{System.Int32})">
            <summary>Construct a VectorR2i from a collection of values.</summary>
            <remarks><code>values</code> must have size 2.</remarks>
            <exception cref="T:System.ArgumentException">If <code>values</code> is not size 2.</exception>
        </member>
        <member name="M:VectorR2i.#ctor(System.Int32[])">
            <summary>Construct a VectorR2i from a collection of values.</summary>
            <remarks>2 parameters must be given.</remarks>
            <exception cref="T:System.ArgumentException">If exactly 2 parameters are not given.</exception>
        </member>
        <member name="M:VectorR2i.#ctor">
             <summary>Constructs a copy of *v*.  
            
             </summary>
        </member>
        <member name="M:VectorR2i.#ctor(System.Int32)">
             <summary>Constructs a copy of *v*.  
            
             </summary>
        </member>
        <member name="M:VectorR2i.#ctor(SWIGTYPE_p_int)">
             <summary>Constructs a copy of *v*.  
            
             </summary>
        </member>
        <member name="M:VectorR2i.#ctor(VectorR2i)">
             <summary>Constructs a copy of *v*.  
            
             </summary>
        </member>
        <member name="M:VectorR2i.set(System.Int32)">
             <summary>Sets all elements of this vector to *element*.  
            
             </summary>
        </member>
        <member name="M:VectorR2i.setElements(SWIGTYPE_p_int)">
             <summary>Copies the elements from *elementArray* to this vector. The array must contain
            *N* elements.  
            
             </summary>
        </member>
        <member name="M:VectorR2i.nonNegative">
             <summary>Returns true if every element of this vector is nonnegative.  
            
             </summary>
        </member>
        <member name="M:VectorR2i.positive">
             <summary>Returns true if every element of this vector is strictly positive.  
            
             </summary>
        </member>
        <member name="M:VectorR2i.size">
            <summary>
            </summary>
        </member>
        <member name="M:VectorR2i.xy">
             <summary>Similar to the OpenGL in shader function that returns the first 2 components of
            a vector. Components that are not defined are defaulted to zero.    note: In
            C++11 compilers, the return is optimized by copy ellision, so actual
                copies take place. See NRVO  
              
            
             </summary>
        </member>
        <member name="M:VectorR2i.xyz">
             <summary>Similar to the opengl in shader function that returns the first 3 components of
            a vector. Components that are not defined are defaulted to zero.    note: In
            C++11 compilers, the return is optimized by copy ellision, so actual
                copies take place. See NRVO  
              
            
             </summary>
        </member>
        <member name="M:VectorR2i.xyzw">
             <summary>Similar to the opengl in shader function that returns the first 3 components of
            a vector. Components that are not defined are defaulted to zero. An undefined W
            coordinate is defaulted to 1.    note: In C++11 compilers, the return is
            optimized by copy ellision, so actual
                copies take place. See NRVO  
              
            
             </summary>
        </member>
        <member name="M:VectorR2i.normalized(System.Double)">
             <summary>Convenience function that uses the vsc::normalize function to return the
            normalized vector  
            
             </summary>
        </member>
        <member name="M:VectorR2i.normalized">
             <summary>Convenience function that uses the vsc::normalize function to return the
            normalized vector  
            
             </summary>
        </member>
        <member name="T:VectorR2iList.VectorR2iListEnumerator">
            Note that the IEnumerator documentation requires an InvalidOperationException to be thrown
            whenever the collection is modified. This has been done for changes in the size of the
            collection but not when one of the elements of the collection is modified as it is a bit
            tricky to detect unmanaged code that modifies the collection under our feet.
        </member>
        <member name="T:VectorR2s">
             <summary>The VectorR template class represents fixed-size, real vectors. The size of the
            vector and the element type are specified as part of the type, and are thus
            fixed at compile time. This vector class represents both positional vectors
            representing points, and covariance vectors such as normal and tangent vectors.  
            *N* is the number of elements, which must be greater than zero. *E* is the
            element type, typically <c>double</c>, <c>float</c>, or <c>int</c>.  
            
            Attributes
            ----------
            * `SIZE` : `const unsigned int`  
                The number of elements in vectors of this type.  
            
             </summary>
        </member>
        <member name="M:VectorR2s.#ctor(System.Collections.Generic.ICollection{System.Int16})">
            <summary>Construct a VectorR2s from a collection of values.</summary>
            <remarks><code>values</code> must have size 2.</remarks>
            <exception cref="T:System.ArgumentException">If <code>values</code> is not size 2.</exception>
        </member>
        <member name="M:VectorR2s.#ctor(System.Int16[])">
            <summary>Construct a VectorR2s from a collection of values.</summary>
            <remarks>2 parameters must be given.</remarks>
            <exception cref="T:System.ArgumentException">If exactly 2 parameters are not given.</exception>
        </member>
        <member name="M:VectorR2s.#ctor">
             <summary>Constructs a copy of *v*.  
            
             </summary>
        </member>
        <member name="M:VectorR2s.#ctor(System.Int16)">
             <summary>Constructs a copy of *v*.  
            
             </summary>
        </member>
        <member name="M:VectorR2s.#ctor(SWIGTYPE_p_short)">
             <summary>Constructs a copy of *v*.  
            
             </summary>
        </member>
        <member name="M:VectorR2s.#ctor(VectorR2s)">
             <summary>Constructs a copy of *v*.  
            
             </summary>
        </member>
        <member name="M:VectorR2s.set(System.Int16)">
             <summary>Sets all elements of this vector to *element*.  
            
             </summary>
        </member>
        <member name="M:VectorR2s.setElements(SWIGTYPE_p_short)">
             <summary>Copies the elements from *elementArray* to this vector. The array must contain
            *N* elements.  
            
             </summary>
        </member>
        <member name="M:VectorR2s.nonNegative">
             <summary>Returns true if every element of this vector is nonnegative.  
            
             </summary>
        </member>
        <member name="M:VectorR2s.positive">
             <summary>Returns true if every element of this vector is strictly positive.  
            
             </summary>
        </member>
        <member name="M:VectorR2s.size">
            <summary>
            </summary>
        </member>
        <member name="M:VectorR2s.xy">
             <summary>Similar to the OpenGL in shader function that returns the first 2 components of
            a vector. Components that are not defined are defaulted to zero.    note: In
            C++11 compilers, the return is optimized by copy ellision, so actual
                copies take place. See NRVO  
              
            
             </summary>
        </member>
        <member name="M:VectorR2s.xyz">
             <summary>Similar to the opengl in shader function that returns the first 3 components of
            a vector. Components that are not defined are defaulted to zero.    note: In
            C++11 compilers, the return is optimized by copy ellision, so actual
                copies take place. See NRVO  
              
            
             </summary>
        </member>
        <member name="M:VectorR2s.xyzw">
             <summary>Similar to the opengl in shader function that returns the first 3 components of
            a vector. Components that are not defined are defaulted to zero. An undefined W
            coordinate is defaulted to 1.    note: In C++11 compilers, the return is
            optimized by copy ellision, so actual
                copies take place. See NRVO  
              
            
             </summary>
        </member>
        <member name="M:VectorR2s.normalized(System.Double)">
             <summary>Convenience function that uses the vsc::normalize function to return the
            normalized vector  
            
             </summary>
        </member>
        <member name="M:VectorR2s.normalized">
             <summary>Convenience function that uses the vsc::normalize function to return the
            normalized vector  
            
             </summary>
        </member>
        <member name="T:VectorR2sList.VectorR2sListEnumerator">
            Note that the IEnumerator documentation requires an InvalidOperationException to be thrown
            whenever the collection is modified. This has been done for changes in the size of the
            collection but not when one of the elements of the collection is modified as it is a bit
            tricky to detect unmanaged code that modifies the collection under our feet.
        </member>
        <member name="T:VectorR2ub">
             <summary>The VectorR template class represents fixed-size, real vectors. The size of the
            vector and the element type are specified as part of the type, and are thus
            fixed at compile time. This vector class represents both positional vectors
            representing points, and covariance vectors such as normal and tangent vectors.  
            *N* is the number of elements, which must be greater than zero. *E* is the
            element type, typically <c>double</c>, <c>float</c>, or <c>int</c>.  
            
            Attributes
            ----------
            * `SIZE` : `const unsigned int`  
                The number of elements in vectors of this type.  
            
             </summary>
        </member>
        <member name="M:VectorR2ub.#ctor(System.Collections.Generic.ICollection{System.Byte})">
            <summary>Construct a VectorR2ub from a collection of values.</summary>
            <remarks><code>values</code> must have size 2.</remarks>
            <exception cref="T:System.ArgumentException">If <code>values</code> is not size 2.</exception>
        </member>
        <member name="M:VectorR2ub.#ctor(System.Byte[])">
            <summary>Construct a VectorR2ub from a collection of values.</summary>
            <remarks>2 parameters must be given.</remarks>
            <exception cref="T:System.ArgumentException">If exactly 2 parameters are not given.</exception>
        </member>
        <member name="M:VectorR2ub.#ctor">
             <summary>Constructs a copy of *v*.  
            
             </summary>
        </member>
        <member name="M:VectorR2ub.#ctor(System.Byte)">
             <summary>Constructs a copy of *v*.  
            
             </summary>
        </member>
        <member name="M:VectorR2ub.#ctor(SWIGTYPE_p_unsigned_char)">
             <summary>Constructs a copy of *v*.  
            
             </summary>
        </member>
        <member name="M:VectorR2ub.#ctor(VectorR2ub)">
             <summary>Constructs a copy of *v*.  
            
             </summary>
        </member>
        <member name="M:VectorR2ub.set(System.Byte)">
             <summary>Sets all elements of this vector to *element*.  
            
             </summary>
        </member>
        <member name="M:VectorR2ub.setElements(SWIGTYPE_p_unsigned_char)">
             <summary>Copies the elements from *elementArray* to this vector. The array must contain
            *N* elements.  
            
             </summary>
        </member>
        <member name="M:VectorR2ub.nonNegative">
             <summary>Returns true if every element of this vector is nonnegative.  
            
             </summary>
        </member>
        <member name="M:VectorR2ub.positive">
             <summary>Returns true if every element of this vector is strictly positive.  
            
             </summary>
        </member>
        <member name="M:VectorR2ub.size">
            <summary>
            </summary>
        </member>
        <member name="M:VectorR2ub.xy">
             <summary>Similar to the OpenGL in shader function that returns the first 2 components of
            a vector. Components that are not defined are defaulted to zero.    note: In
            C++11 compilers, the return is optimized by copy ellision, so actual
                copies take place. See NRVO  
              
            
             </summary>
        </member>
        <member name="M:VectorR2ub.xyz">
             <summary>Similar to the opengl in shader function that returns the first 3 components of
            a vector. Components that are not defined are defaulted to zero.    note: In
            C++11 compilers, the return is optimized by copy ellision, so actual
                copies take place. See NRVO  
              
            
             </summary>
        </member>
        <member name="M:VectorR2ub.xyzw">
             <summary>Similar to the opengl in shader function that returns the first 3 components of
            a vector. Components that are not defined are defaulted to zero. An undefined W
            coordinate is defaulted to 1.    note: In C++11 compilers, the return is
            optimized by copy ellision, so actual
                copies take place. See NRVO  
              
            
             </summary>
        </member>
        <member name="M:VectorR2ub.normalized(System.Double)">
             <summary>Convenience function that uses the vsc::normalize function to return the
            normalized vector  
            
             </summary>
        </member>
        <member name="M:VectorR2ub.normalized">
             <summary>Convenience function that uses the vsc::normalize function to return the
            normalized vector  
            
             </summary>
        </member>
        <member name="T:VectorR2ubList.VectorR2ubListEnumerator">
            Note that the IEnumerator documentation requires an InvalidOperationException to be thrown
            whenever the collection is modified. This has been done for changes in the size of the
            collection but not when one of the elements of the collection is modified as it is a bit
            tricky to detect unmanaged code that modifies the collection under our feet.
        </member>
        <member name="T:VectorR2ui">
             <summary>The VectorR template class represents fixed-size, real vectors. The size of the
            vector and the element type are specified as part of the type, and are thus
            fixed at compile time. This vector class represents both positional vectors
            representing points, and covariance vectors such as normal and tangent vectors.  
            *N* is the number of elements, which must be greater than zero. *E* is the
            element type, typically <c>double</c>, <c>float</c>, or <c>int</c>.  
            
            Attributes
            ----------
            * `SIZE` : `const unsigned int`  
                The number of elements in vectors of this type.  
            
             </summary>
        </member>
        <member name="M:VectorR2ui.#ctor(System.Collections.Generic.ICollection{System.UInt32})">
            <summary>Construct a VectorR2ui from a collection of values.</summary>
            <remarks><code>values</code> must have size 2.</remarks>
            <exception cref="T:System.ArgumentException">If <code>values</code> is not size 2.</exception>
        </member>
        <member name="M:VectorR2ui.#ctor(System.UInt32[])">
            <summary>Construct a VectorR2ui from a collection of values.</summary>
            <remarks>2 parameters must be given.</remarks>
            <exception cref="T:System.ArgumentException">If exactly 2 parameters are not given.</exception>
        </member>
        <member name="M:VectorR2ui.#ctor">
             <summary>Constructs a copy of *v*.  
            
             </summary>
        </member>
        <member name="M:VectorR2ui.#ctor(System.UInt32)">
             <summary>Constructs a copy of *v*.  
            
             </summary>
        </member>
        <member name="M:VectorR2ui.#ctor(SWIGTYPE_p_unsigned_int)">
             <summary>Constructs a copy of *v*.  
            
             </summary>
        </member>
        <member name="M:VectorR2ui.#ctor(VectorR2ui)">
             <summary>Constructs a copy of *v*.  
            
             </summary>
        </member>
        <member name="M:VectorR2ui.set(System.UInt32)">
             <summary>Sets all elements of this vector to *element*.  
            
             </summary>
        </member>
        <member name="M:VectorR2ui.setElements(SWIGTYPE_p_unsigned_int)">
             <summary>Copies the elements from *elementArray* to this vector. The array must contain
            *N* elements.  
            
             </summary>
        </member>
        <member name="M:VectorR2ui.nonNegative">
             <summary>Returns true if every element of this vector is nonnegative.  
            
             </summary>
        </member>
        <member name="M:VectorR2ui.positive">
             <summary>Returns true if every element of this vector is strictly positive.  
            
             </summary>
        </member>
        <member name="M:VectorR2ui.size">
            <summary>
            </summary>
        </member>
        <member name="M:VectorR2ui.xy">
             <summary>Similar to the OpenGL in shader function that returns the first 2 components of
            a vector. Components that are not defined are defaulted to zero.    note: In
            C++11 compilers, the return is optimized by copy ellision, so actual
                copies take place. See NRVO  
              
            
             </summary>
        </member>
        <member name="M:VectorR2ui.xyz">
             <summary>Similar to the opengl in shader function that returns the first 3 components of
            a vector. Components that are not defined are defaulted to zero.    note: In
            C++11 compilers, the return is optimized by copy ellision, so actual
                copies take place. See NRVO  
              
            
             </summary>
        </member>
        <member name="M:VectorR2ui.xyzw">
             <summary>Similar to the opengl in shader function that returns the first 3 components of
            a vector. Components that are not defined are defaulted to zero. An undefined W
            coordinate is defaulted to 1.    note: In C++11 compilers, the return is
            optimized by copy ellision, so actual
                copies take place. See NRVO  
              
            
             </summary>
        </member>
        <member name="M:VectorR2ui.normalized(System.Double)">
             <summary>Convenience function that uses the vsc::normalize function to return the
            normalized vector  
            
             </summary>
        </member>
        <member name="M:VectorR2ui.normalized">
             <summary>Convenience function that uses the vsc::normalize function to return the
            normalized vector  
            
             </summary>
        </member>
        <member name="T:VectorR2uiList.VectorR2uiListEnumerator">
            Note that the IEnumerator documentation requires an InvalidOperationException to be thrown
            whenever the collection is modified. This has been done for changes in the size of the
            collection but not when one of the elements of the collection is modified as it is a bit
            tricky to detect unmanaged code that modifies the collection under our feet.
        </member>
        <member name="T:VectorR2us">
             <summary>The VectorR template class represents fixed-size, real vectors. The size of the
            vector and the element type are specified as part of the type, and are thus
            fixed at compile time. This vector class represents both positional vectors
            representing points, and covariance vectors such as normal and tangent vectors.  
            *N* is the number of elements, which must be greater than zero. *E* is the
            element type, typically <c>double</c>, <c>float</c>, or <c>int</c>.  
            
            Attributes
            ----------
            * `SIZE` : `const unsigned int`  
                The number of elements in vectors of this type.  
            
             </summary>
        </member>
        <member name="M:VectorR2us.#ctor(System.Collections.Generic.ICollection{System.UInt16})">
            <summary>Construct a VectorR2us from a collection of values.</summary>
            <remarks><code>values</code> must have size 2.</remarks>
            <exception cref="T:System.ArgumentException">If <code>values</code> is not size 2.</exception>
        </member>
        <member name="M:VectorR2us.#ctor(System.UInt16[])">
            <summary>Construct a VectorR2us from a collection of values.</summary>
            <remarks>2 parameters must be given.</remarks>
            <exception cref="T:System.ArgumentException">If exactly 2 parameters are not given.</exception>
        </member>
        <member name="M:VectorR2us.#ctor">
             <summary>Constructs a copy of *v*.  
            
             </summary>
        </member>
        <member name="M:VectorR2us.#ctor(System.UInt16)">
             <summary>Constructs a copy of *v*.  
            
             </summary>
        </member>
        <member name="M:VectorR2us.#ctor(SWIGTYPE_p_unsigned_short)">
             <summary>Constructs a copy of *v*.  
            
             </summary>
        </member>
        <member name="M:VectorR2us.#ctor(VectorR2us)">
             <summary>Constructs a copy of *v*.  
            
             </summary>
        </member>
        <member name="M:VectorR2us.set(System.UInt16)">
             <summary>Sets all elements of this vector to *element*.  
            
             </summary>
        </member>
        <member name="M:VectorR2us.setElements(SWIGTYPE_p_unsigned_short)">
             <summary>Copies the elements from *elementArray* to this vector. The array must contain
            *N* elements.  
            
             </summary>
        </member>
        <member name="M:VectorR2us.nonNegative">
             <summary>Returns true if every element of this vector is nonnegative.  
            
             </summary>
        </member>
        <member name="M:VectorR2us.positive">
             <summary>Returns true if every element of this vector is strictly positive.  
            
             </summary>
        </member>
        <member name="M:VectorR2us.size">
            <summary>
            </summary>
        </member>
        <member name="M:VectorR2us.xy">
             <summary>Similar to the OpenGL in shader function that returns the first 2 components of
            a vector. Components that are not defined are defaulted to zero.    note: In
            C++11 compilers, the return is optimized by copy ellision, so actual
                copies take place. See NRVO  
              
            
             </summary>
        </member>
        <member name="M:VectorR2us.xyz">
             <summary>Similar to the opengl in shader function that returns the first 3 components of
            a vector. Components that are not defined are defaulted to zero.    note: In
            C++11 compilers, the return is optimized by copy ellision, so actual
                copies take place. See NRVO  
              
            
             </summary>
        </member>
        <member name="M:VectorR2us.xyzw">
             <summary>Similar to the opengl in shader function that returns the first 3 components of
            a vector. Components that are not defined are defaulted to zero. An undefined W
            coordinate is defaulted to 1.    note: In C++11 compilers, the return is
            optimized by copy ellision, so actual
                copies take place. See NRVO  
              
            
             </summary>
        </member>
        <member name="M:VectorR2us.normalized(System.Double)">
             <summary>Convenience function that uses the vsc::normalize function to return the
            normalized vector  
            
             </summary>
        </member>
        <member name="M:VectorR2us.normalized">
             <summary>Convenience function that uses the vsc::normalize function to return the
            normalized vector  
            
             </summary>
        </member>
        <member name="T:VectorR2usList.VectorR2usListEnumerator">
            Note that the IEnumerator documentation requires an InvalidOperationException to be thrown
            whenever the collection is modified. This has been done for changes in the size of the
            collection but not when one of the elements of the collection is modified as it is a bit
            tricky to detect unmanaged code that modifies the collection under our feet.
        </member>
        <member name="T:VectorR3b">
             <summary>The VectorR template class represents fixed-size, real vectors. The size of the
            vector and the element type are specified as part of the type, and are thus
            fixed at compile time. This vector class represents both positional vectors
            representing points, and covariance vectors such as normal and tangent vectors.  
            *N* is the number of elements, which must be greater than zero. *E* is the
            element type, typically <c>double</c>, <c>float</c>, or <c>int</c>.  
            
            Attributes
            ----------
            * `SIZE` : `const unsigned int`  
                The number of elements in vectors of this type.  
            
             </summary>
        </member>
        <member name="M:VectorR3b.#ctor(System.Collections.Generic.ICollection{System.Char})">
            <summary>Construct a VectorR3b from a collection of values.</summary>
            <remarks><code>values</code> must have size 3.</remarks>
            <exception cref="T:System.ArgumentException">If <code>values</code> is not size 3.</exception>
        </member>
        <member name="M:VectorR3b.#ctor(System.Char[])">
            <summary>Construct a VectorR3b from a collection of values.</summary>
            <remarks>3 parameters must be given.</remarks>
            <exception cref="T:System.ArgumentException">If exactly 3 parameters are not given.</exception>
        </member>
        <member name="M:VectorR3b.#ctor">
             <summary>Constructs a copy of *v*.  
            
             </summary>
        </member>
        <member name="M:VectorR3b.#ctor(System.Char)">
             <summary>Constructs a copy of *v*.  
            
             </summary>
        </member>
        <member name="M:VectorR3b.#ctor(System.String)">
             <summary>Constructs a copy of *v*.  
            
             </summary>
        </member>
        <member name="M:VectorR3b.#ctor(VectorR3b)">
             <summary>Constructs a copy of *v*.  
            
             </summary>
        </member>
        <member name="M:VectorR3b.set(System.Char)">
             <summary>Sets all elements of this vector to *element*.  
            
             </summary>
        </member>
        <member name="M:VectorR3b.setElements(System.String)">
             <summary>Copies the elements from *elementArray* to this vector. The array must contain
            *N* elements.  
            
             </summary>
        </member>
        <member name="M:VectorR3b.nonNegative">
             <summary>Returns true if every element of this vector is nonnegative.  
            
             </summary>
        </member>
        <member name="M:VectorR3b.positive">
             <summary>Returns true if every element of this vector is strictly positive.  
            
             </summary>
        </member>
        <member name="M:VectorR3b.size">
            <summary>
            </summary>
        </member>
        <member name="M:VectorR3b.xy">
             <summary>Similar to the OpenGL in shader function that returns the first 2 components of
            a vector. Components that are not defined are defaulted to zero.    note: In
            C++11 compilers, the return is optimized by copy ellision, so actual
                copies take place. See NRVO  
              
            
             </summary>
        </member>
        <member name="M:VectorR3b.xyz">
             <summary>Similar to the opengl in shader function that returns the first 3 components of
            a vector. Components that are not defined are defaulted to zero.    note: In
            C++11 compilers, the return is optimized by copy ellision, so actual
                copies take place. See NRVO  
              
            
             </summary>
        </member>
        <member name="M:VectorR3b.xyzw">
             <summary>Similar to the opengl in shader function that returns the first 3 components of
            a vector. Components that are not defined are defaulted to zero. An undefined W
            coordinate is defaulted to 1.    note: In C++11 compilers, the return is
            optimized by copy ellision, so actual
                copies take place. See NRVO  
              
            
             </summary>
        </member>
        <member name="M:VectorR3b.normalized(System.Double)">
             <summary>Convenience function that uses the vsc::normalize function to return the
            normalized vector  
            
             </summary>
        </member>
        <member name="M:VectorR3b.normalized">
             <summary>Convenience function that uses the vsc::normalize function to return the
            normalized vector  
            
             </summary>
        </member>
        <member name="T:VectorR3bList.VectorR3bListEnumerator">
            Note that the IEnumerator documentation requires an InvalidOperationException to be thrown
            whenever the collection is modified. This has been done for changes in the size of the
            collection but not when one of the elements of the collection is modified as it is a bit
            tricky to detect unmanaged code that modifies the collection under our feet.
        </member>
        <member name="T:VectorR3d">
             <summary>The VectorR template class represents fixed-size, real vectors. The size of the
            vector and the element type are specified as part of the type, and are thus
            fixed at compile time. This vector class represents both positional vectors
            representing points, and covariance vectors such as normal and tangent vectors.  
            *N* is the number of elements, which must be greater than zero. *E* is the
            element type, typically <c>double</c>, <c>float</c>, or <c>int</c>.  
            
            Attributes
            ----------
            * `SIZE` : `const unsigned int`  
                The number of elements in vectors of this type.  
            
             </summary>
        </member>
        <member name="M:VectorR3d.#ctor(System.Collections.Generic.ICollection{System.Double})">
            <summary>Construct a VectorR3d from a collection of values.</summary>
            <remarks><code>values</code> must have size 3.</remarks>
            <exception cref="T:System.ArgumentException">If <code>values</code> is not size 3.</exception>
        </member>
        <member name="M:VectorR3d.#ctor(System.Double[])">
            <summary>Construct a VectorR3d from a collection of values.</summary>
            <remarks>3 parameters must be given.</remarks>
            <exception cref="T:System.ArgumentException">If exactly 3 parameters are not given.</exception>
        </member>
        <member name="M:VectorR3d.#ctor">
             <summary>Constructs a copy of *v*.  
            
             </summary>
        </member>
        <member name="M:VectorR3d.#ctor(System.Double)">
             <summary>Constructs a copy of *v*.  
            
             </summary>
        </member>
        <member name="M:VectorR3d.#ctor(SWIGTYPE_p_double)">
             <summary>Constructs a copy of *v*.  
            
             </summary>
        </member>
        <member name="M:VectorR3d.#ctor(VectorR3d)">
             <summary>Constructs a copy of *v*.  
            
             </summary>
        </member>
        <member name="M:VectorR3d.set(System.Double)">
             <summary>Sets all elements of this vector to *element*.  
            
             </summary>
        </member>
        <member name="M:VectorR3d.setElements(SWIGTYPE_p_double)">
             <summary>Copies the elements from *elementArray* to this vector. The array must contain
            *N* elements.  
            
             </summary>
        </member>
        <member name="M:VectorR3d.nonNegative">
             <summary>Returns true if every element of this vector is nonnegative.  
            
             </summary>
        </member>
        <member name="M:VectorR3d.positive">
             <summary>Returns true if every element of this vector is strictly positive.  
            
             </summary>
        </member>
        <member name="M:VectorR3d.size">
            <summary>
            </summary>
        </member>
        <member name="M:VectorR3d.xy">
             <summary>Similar to the OpenGL in shader function that returns the first 2 components of
            a vector. Components that are not defined are defaulted to zero.    note: In
            C++11 compilers, the return is optimized by copy ellision, so actual
                copies take place. See NRVO  
              
            
             </summary>
        </member>
        <member name="M:VectorR3d.xyz">
             <summary>Similar to the opengl in shader function that returns the first 3 components of
            a vector. Components that are not defined are defaulted to zero.    note: In
            C++11 compilers, the return is optimized by copy ellision, so actual
                copies take place. See NRVO  
              
            
             </summary>
        </member>
        <member name="M:VectorR3d.xyzw">
             <summary>Similar to the opengl in shader function that returns the first 3 components of
            a vector. Components that are not defined are defaulted to zero. An undefined W
            coordinate is defaulted to 1.    note: In C++11 compilers, the return is
            optimized by copy ellision, so actual
                copies take place. See NRVO  
              
            
             </summary>
        </member>
        <member name="M:VectorR3d.normalized(System.Double)">
             <summary>Convenience function that uses the vsc::normalize function to return the
            normalized vector  
            
             </summary>
        </member>
        <member name="M:VectorR3d.normalized">
             <summary>Convenience function that uses the vsc::normalize function to return the
            normalized vector  
            
             </summary>
        </member>
        <member name="T:VectorR3dList.VectorR3dListEnumerator">
            Note that the IEnumerator documentation requires an InvalidOperationException to be thrown
            whenever the collection is modified. This has been done for changes in the size of the
            collection but not when one of the elements of the collection is modified as it is a bit
            tricky to detect unmanaged code that modifies the collection under our feet.
        </member>
        <member name="T:VectorR3f">
             <summary>The VectorR template class represents fixed-size, real vectors. The size of the
            vector and the element type are specified as part of the type, and are thus
            fixed at compile time. This vector class represents both positional vectors
            representing points, and covariance vectors such as normal and tangent vectors.  
            *N* is the number of elements, which must be greater than zero. *E* is the
            element type, typically <c>double</c>, <c>float</c>, or <c>int</c>.  
            
            Attributes
            ----------
            * `SIZE` : `const unsigned int`  
                The number of elements in vectors of this type.  
            
             </summary>
        </member>
        <member name="M:VectorR3f.#ctor(System.Collections.Generic.ICollection{System.Single})">
            <summary>Construct a VectorR3f from a collection of values.</summary>
            <remarks><code>values</code> must have size 3.</remarks>
            <exception cref="T:System.ArgumentException">If <code>values</code> is not size 3.</exception>
        </member>
        <member name="M:VectorR3f.#ctor(System.Single[])">
            <summary>Construct a VectorR3f from a collection of values.</summary>
            <remarks>3 parameters must be given.</remarks>
            <exception cref="T:System.ArgumentException">If exactly 3 parameters are not given.</exception>
        </member>
        <member name="M:VectorR3f.#ctor">
             <summary>Constructs a copy of *v*.  
            
             </summary>
        </member>
        <member name="M:VectorR3f.#ctor(System.Single)">
             <summary>Constructs a copy of *v*.  
            
             </summary>
        </member>
        <member name="M:VectorR3f.#ctor(SWIGTYPE_p_float)">
             <summary>Constructs a copy of *v*.  
            
             </summary>
        </member>
        <member name="M:VectorR3f.#ctor(VectorR3f)">
             <summary>Constructs a copy of *v*.  
            
             </summary>
        </member>
        <member name="M:VectorR3f.set(System.Single)">
             <summary>Sets all elements of this vector to *element*.  
            
             </summary>
        </member>
        <member name="M:VectorR3f.setElements(SWIGTYPE_p_float)">
             <summary>Copies the elements from *elementArray* to this vector. The array must contain
            *N* elements.  
            
             </summary>
        </member>
        <member name="M:VectorR3f.nonNegative">
             <summary>Returns true if every element of this vector is nonnegative.  
            
             </summary>
        </member>
        <member name="M:VectorR3f.positive">
             <summary>Returns true if every element of this vector is strictly positive.  
            
             </summary>
        </member>
        <member name="M:VectorR3f.size">
            <summary>
            </summary>
        </member>
        <member name="M:VectorR3f.xy">
             <summary>Similar to the OpenGL in shader function that returns the first 2 components of
            a vector. Components that are not defined are defaulted to zero.    note: In
            C++11 compilers, the return is optimized by copy ellision, so actual
                copies take place. See NRVO  
              
            
             </summary>
        </member>
        <member name="M:VectorR3f.xyz">
             <summary>Similar to the opengl in shader function that returns the first 3 components of
            a vector. Components that are not defined are defaulted to zero.    note: In
            C++11 compilers, the return is optimized by copy ellision, so actual
                copies take place. See NRVO  
              
            
             </summary>
        </member>
        <member name="M:VectorR3f.xyzw">
             <summary>Similar to the opengl in shader function that returns the first 3 components of
            a vector. Components that are not defined are defaulted to zero. An undefined W
            coordinate is defaulted to 1.    note: In C++11 compilers, the return is
            optimized by copy ellision, so actual
                copies take place. See NRVO  
              
            
             </summary>
        </member>
        <member name="M:VectorR3f.normalized(System.Double)">
             <summary>Convenience function that uses the vsc::normalize function to return the
            normalized vector  
            
             </summary>
        </member>
        <member name="M:VectorR3f.normalized">
             <summary>Convenience function that uses the vsc::normalize function to return the
            normalized vector  
            
             </summary>
        </member>
        <member name="T:VectorR3fList.VectorR3fListEnumerator">
            Note that the IEnumerator documentation requires an InvalidOperationException to be thrown
            whenever the collection is modified. This has been done for changes in the size of the
            collection but not when one of the elements of the collection is modified as it is a bit
            tricky to detect unmanaged code that modifies the collection under our feet.
        </member>
        <member name="T:VectorR3i">
             <summary>The VectorR template class represents fixed-size, real vectors. The size of the
            vector and the element type are specified as part of the type, and are thus
            fixed at compile time. This vector class represents both positional vectors
            representing points, and covariance vectors such as normal and tangent vectors.  
            *N* is the number of elements, which must be greater than zero. *E* is the
            element type, typically <c>double</c>, <c>float</c>, or <c>int</c>.  
            
            Attributes
            ----------
            * `SIZE` : `const unsigned int`  
                The number of elements in vectors of this type.  
            
             </summary>
        </member>
        <member name="M:VectorR3i.#ctor(System.Collections.Generic.ICollection{System.Int32})">
            <summary>Construct a VectorR3i from a collection of values.</summary>
            <remarks><code>values</code> must have size 3.</remarks>
            <exception cref="T:System.ArgumentException">If <code>values</code> is not size 3.</exception>
        </member>
        <member name="M:VectorR3i.#ctor(System.Int32[])">
            <summary>Construct a VectorR3i from a collection of values.</summary>
            <remarks>3 parameters must be given.</remarks>
            <exception cref="T:System.ArgumentException">If exactly 3 parameters are not given.</exception>
        </member>
        <member name="M:VectorR3i.#ctor">
             <summary>Constructs a copy of *v*.  
            
             </summary>
        </member>
        <member name="M:VectorR3i.#ctor(System.Int32)">
             <summary>Constructs a copy of *v*.  
            
             </summary>
        </member>
        <member name="M:VectorR3i.#ctor(SWIGTYPE_p_int)">
             <summary>Constructs a copy of *v*.  
            
             </summary>
        </member>
        <member name="M:VectorR3i.#ctor(VectorR3i)">
             <summary>Constructs a copy of *v*.  
            
             </summary>
        </member>
        <member name="M:VectorR3i.set(System.Int32)">
             <summary>Sets all elements of this vector to *element*.  
            
             </summary>
        </member>
        <member name="M:VectorR3i.setElements(SWIGTYPE_p_int)">
             <summary>Copies the elements from *elementArray* to this vector. The array must contain
            *N* elements.  
            
             </summary>
        </member>
        <member name="M:VectorR3i.nonNegative">
             <summary>Returns true if every element of this vector is nonnegative.  
            
             </summary>
        </member>
        <member name="M:VectorR3i.positive">
             <summary>Returns true if every element of this vector is strictly positive.  
            
             </summary>
        </member>
        <member name="M:VectorR3i.size">
            <summary>
            </summary>
        </member>
        <member name="M:VectorR3i.xy">
             <summary>Similar to the OpenGL in shader function that returns the first 2 components of
            a vector. Components that are not defined are defaulted to zero.    note: In
            C++11 compilers, the return is optimized by copy ellision, so actual
                copies take place. See NRVO  
              
            
             </summary>
        </member>
        <member name="M:VectorR3i.xyz">
             <summary>Similar to the opengl in shader function that returns the first 3 components of
            a vector. Components that are not defined are defaulted to zero.    note: In
            C++11 compilers, the return is optimized by copy ellision, so actual
                copies take place. See NRVO  
              
            
             </summary>
        </member>
        <member name="M:VectorR3i.xyzw">
             <summary>Similar to the opengl in shader function that returns the first 3 components of
            a vector. Components that are not defined are defaulted to zero. An undefined W
            coordinate is defaulted to 1.    note: In C++11 compilers, the return is
            optimized by copy ellision, so actual
                copies take place. See NRVO  
              
            
             </summary>
        </member>
        <member name="M:VectorR3i.normalized(System.Double)">
             <summary>Convenience function that uses the vsc::normalize function to return the
            normalized vector  
            
             </summary>
        </member>
        <member name="M:VectorR3i.normalized">
             <summary>Convenience function that uses the vsc::normalize function to return the
            normalized vector  
            
             </summary>
        </member>
        <member name="T:VectorR3iList.VectorR3iListEnumerator">
            Note that the IEnumerator documentation requires an InvalidOperationException to be thrown
            whenever the collection is modified. This has been done for changes in the size of the
            collection but not when one of the elements of the collection is modified as it is a bit
            tricky to detect unmanaged code that modifies the collection under our feet.
        </member>
        <member name="T:VectorR3s">
             <summary>The VectorR template class represents fixed-size, real vectors. The size of the
            vector and the element type are specified as part of the type, and are thus
            fixed at compile time. This vector class represents both positional vectors
            representing points, and covariance vectors such as normal and tangent vectors.  
            *N* is the number of elements, which must be greater than zero. *E* is the
            element type, typically <c>double</c>, <c>float</c>, or <c>int</c>.  
            
            Attributes
            ----------
            * `SIZE` : `const unsigned int`  
                The number of elements in vectors of this type.  
            
             </summary>
        </member>
        <member name="M:VectorR3s.#ctor(System.Collections.Generic.ICollection{System.Int16})">
            <summary>Construct a VectorR3s from a collection of values.</summary>
            <remarks><code>values</code> must have size 3.</remarks>
            <exception cref="T:System.ArgumentException">If <code>values</code> is not size 3.</exception>
        </member>
        <member name="M:VectorR3s.#ctor(System.Int16[])">
            <summary>Construct a VectorR3s from a collection of values.</summary>
            <remarks>3 parameters must be given.</remarks>
            <exception cref="T:System.ArgumentException">If exactly 3 parameters are not given.</exception>
        </member>
        <member name="M:VectorR3s.#ctor">
             <summary>Constructs a copy of *v*.  
            
             </summary>
        </member>
        <member name="M:VectorR3s.#ctor(System.Int16)">
             <summary>Constructs a copy of *v*.  
            
             </summary>
        </member>
        <member name="M:VectorR3s.#ctor(SWIGTYPE_p_short)">
             <summary>Constructs a copy of *v*.  
            
             </summary>
        </member>
        <member name="M:VectorR3s.#ctor(VectorR3s)">
             <summary>Constructs a copy of *v*.  
            
             </summary>
        </member>
        <member name="M:VectorR3s.set(System.Int16)">
             <summary>Sets all elements of this vector to *element*.  
            
             </summary>
        </member>
        <member name="M:VectorR3s.setElements(SWIGTYPE_p_short)">
             <summary>Copies the elements from *elementArray* to this vector. The array must contain
            *N* elements.  
            
             </summary>
        </member>
        <member name="M:VectorR3s.nonNegative">
             <summary>Returns true if every element of this vector is nonnegative.  
            
             </summary>
        </member>
        <member name="M:VectorR3s.positive">
             <summary>Returns true if every element of this vector is strictly positive.  
            
             </summary>
        </member>
        <member name="M:VectorR3s.size">
            <summary>
            </summary>
        </member>
        <member name="M:VectorR3s.xy">
             <summary>Similar to the OpenGL in shader function that returns the first 2 components of
            a vector. Components that are not defined are defaulted to zero.    note: In
            C++11 compilers, the return is optimized by copy ellision, so actual
                copies take place. See NRVO  
              
            
             </summary>
        </member>
        <member name="M:VectorR3s.xyz">
             <summary>Similar to the opengl in shader function that returns the first 3 components of
            a vector. Components that are not defined are defaulted to zero.    note: In
            C++11 compilers, the return is optimized by copy ellision, so actual
                copies take place. See NRVO  
              
            
             </summary>
        </member>
        <member name="M:VectorR3s.xyzw">
             <summary>Similar to the opengl in shader function that returns the first 3 components of
            a vector. Components that are not defined are defaulted to zero. An undefined W
            coordinate is defaulted to 1.    note: In C++11 compilers, the return is
            optimized by copy ellision, so actual
                copies take place. See NRVO  
              
            
             </summary>
        </member>
        <member name="M:VectorR3s.normalized(System.Double)">
             <summary>Convenience function that uses the vsc::normalize function to return the
            normalized vector  
            
             </summary>
        </member>
        <member name="M:VectorR3s.normalized">
             <summary>Convenience function that uses the vsc::normalize function to return the
            normalized vector  
            
             </summary>
        </member>
        <member name="T:VectorR3sList.VectorR3sListEnumerator">
            Note that the IEnumerator documentation requires an InvalidOperationException to be thrown
            whenever the collection is modified. This has been done for changes in the size of the
            collection but not when one of the elements of the collection is modified as it is a bit
            tricky to detect unmanaged code that modifies the collection under our feet.
        </member>
        <member name="T:VectorR3ub">
             <summary>The VectorR template class represents fixed-size, real vectors. The size of the
            vector and the element type are specified as part of the type, and are thus
            fixed at compile time. This vector class represents both positional vectors
            representing points, and covariance vectors such as normal and tangent vectors.  
            *N* is the number of elements, which must be greater than zero. *E* is the
            element type, typically <c>double</c>, <c>float</c>, or <c>int</c>.  
            
            Attributes
            ----------
            * `SIZE` : `const unsigned int`  
                The number of elements in vectors of this type.  
            
             </summary>
        </member>
        <member name="M:VectorR3ub.#ctor(System.Collections.Generic.ICollection{System.Byte})">
            <summary>Construct a VectorR3ub from a collection of values.</summary>
            <remarks><code>values</code> must have size 3.</remarks>
            <exception cref="T:System.ArgumentException">If <code>values</code> is not size 3.</exception>
        </member>
        <member name="M:VectorR3ub.#ctor(System.Byte[])">
            <summary>Construct a VectorR3ub from a collection of values.</summary>
            <remarks>3 parameters must be given.</remarks>
            <exception cref="T:System.ArgumentException">If exactly 3 parameters are not given.</exception>
        </member>
        <member name="M:VectorR3ub.#ctor">
             <summary>Constructs a copy of *v*.  
            
             </summary>
        </member>
        <member name="M:VectorR3ub.#ctor(System.Byte)">
             <summary>Constructs a copy of *v*.  
            
             </summary>
        </member>
        <member name="M:VectorR3ub.#ctor(SWIGTYPE_p_unsigned_char)">
             <summary>Constructs a copy of *v*.  
            
             </summary>
        </member>
        <member name="M:VectorR3ub.#ctor(VectorR3ub)">
             <summary>Constructs a copy of *v*.  
            
             </summary>
        </member>
        <member name="M:VectorR3ub.set(System.Byte)">
             <summary>Sets all elements of this vector to *element*.  
            
             </summary>
        </member>
        <member name="M:VectorR3ub.setElements(SWIGTYPE_p_unsigned_char)">
             <summary>Copies the elements from *elementArray* to this vector. The array must contain
            *N* elements.  
            
             </summary>
        </member>
        <member name="M:VectorR3ub.nonNegative">
             <summary>Returns true if every element of this vector is nonnegative.  
            
             </summary>
        </member>
        <member name="M:VectorR3ub.positive">
             <summary>Returns true if every element of this vector is strictly positive.  
            
             </summary>
        </member>
        <member name="M:VectorR3ub.size">
            <summary>
            </summary>
        </member>
        <member name="M:VectorR3ub.xy">
             <summary>Similar to the OpenGL in shader function that returns the first 2 components of
            a vector. Components that are not defined are defaulted to zero.    note: In
            C++11 compilers, the return is optimized by copy ellision, so actual
                copies take place. See NRVO  
              
            
             </summary>
        </member>
        <member name="M:VectorR3ub.xyz">
             <summary>Similar to the opengl in shader function that returns the first 3 components of
            a vector. Components that are not defined are defaulted to zero.    note: In
            C++11 compilers, the return is optimized by copy ellision, so actual
                copies take place. See NRVO  
              
            
             </summary>
        </member>
        <member name="M:VectorR3ub.xyzw">
             <summary>Similar to the opengl in shader function that returns the first 3 components of
            a vector. Components that are not defined are defaulted to zero. An undefined W
            coordinate is defaulted to 1.    note: In C++11 compilers, the return is
            optimized by copy ellision, so actual
                copies take place. See NRVO  
              
            
             </summary>
        </member>
        <member name="M:VectorR3ub.normalized(System.Double)">
             <summary>Convenience function that uses the vsc::normalize function to return the
            normalized vector  
            
             </summary>
        </member>
        <member name="M:VectorR3ub.normalized">
             <summary>Convenience function that uses the vsc::normalize function to return the
            normalized vector  
            
             </summary>
        </member>
        <member name="T:VectorR3ubList.VectorR3ubListEnumerator">
            Note that the IEnumerator documentation requires an InvalidOperationException to be thrown
            whenever the collection is modified. This has been done for changes in the size of the
            collection but not when one of the elements of the collection is modified as it is a bit
            tricky to detect unmanaged code that modifies the collection under our feet.
        </member>
        <member name="T:VectorR3ui">
             <summary>The VectorR template class represents fixed-size, real vectors. The size of the
            vector and the element type are specified as part of the type, and are thus
            fixed at compile time. This vector class represents both positional vectors
            representing points, and covariance vectors such as normal and tangent vectors.  
            *N* is the number of elements, which must be greater than zero. *E* is the
            element type, typically <c>double</c>, <c>float</c>, or <c>int</c>.  
            
            Attributes
            ----------
            * `SIZE` : `const unsigned int`  
                The number of elements in vectors of this type.  
            
             </summary>
        </member>
        <member name="M:VectorR3ui.#ctor(System.Collections.Generic.ICollection{System.UInt32})">
            <summary>Construct a VectorR3ui from a collection of values.</summary>
            <remarks><code>values</code> must have size 3.</remarks>
            <exception cref="T:System.ArgumentException">If <code>values</code> is not size 3.</exception>
        </member>
        <member name="M:VectorR3ui.#ctor(System.UInt32[])">
            <summary>Construct a VectorR3ui from a collection of values.</summary>
            <remarks>3 parameters must be given.</remarks>
            <exception cref="T:System.ArgumentException">If exactly 3 parameters are not given.</exception>
        </member>
        <member name="M:VectorR3ui.#ctor">
             <summary>Constructs a copy of *v*.  
            
             </summary>
        </member>
        <member name="M:VectorR3ui.#ctor(System.UInt32)">
             <summary>Constructs a copy of *v*.  
            
             </summary>
        </member>
        <member name="M:VectorR3ui.#ctor(SWIGTYPE_p_unsigned_int)">
             <summary>Constructs a copy of *v*.  
            
             </summary>
        </member>
        <member name="M:VectorR3ui.#ctor(VectorR3ui)">
             <summary>Constructs a copy of *v*.  
            
             </summary>
        </member>
        <member name="M:VectorR3ui.set(System.UInt32)">
             <summary>Sets all elements of this vector to *element*.  
            
             </summary>
        </member>
        <member name="M:VectorR3ui.setElements(SWIGTYPE_p_unsigned_int)">
             <summary>Copies the elements from *elementArray* to this vector. The array must contain
            *N* elements.  
            
             </summary>
        </member>
        <member name="M:VectorR3ui.nonNegative">
             <summary>Returns true if every element of this vector is nonnegative.  
            
             </summary>
        </member>
        <member name="M:VectorR3ui.positive">
             <summary>Returns true if every element of this vector is strictly positive.  
            
             </summary>
        </member>
        <member name="M:VectorR3ui.size">
            <summary>
            </summary>
        </member>
        <member name="M:VectorR3ui.xy">
             <summary>Similar to the OpenGL in shader function that returns the first 2 components of
            a vector. Components that are not defined are defaulted to zero.    note: In
            C++11 compilers, the return is optimized by copy ellision, so actual
                copies take place. See NRVO  
              
            
             </summary>
        </member>
        <member name="M:VectorR3ui.xyz">
             <summary>Similar to the opengl in shader function that returns the first 3 components of
            a vector. Components that are not defined are defaulted to zero.    note: In
            C++11 compilers, the return is optimized by copy ellision, so actual
                copies take place. See NRVO  
              
            
             </summary>
        </member>
        <member name="M:VectorR3ui.xyzw">
             <summary>Similar to the opengl in shader function that returns the first 3 components of
            a vector. Components that are not defined are defaulted to zero. An undefined W
            coordinate is defaulted to 1.    note: In C++11 compilers, the return is
            optimized by copy ellision, so actual
                copies take place. See NRVO  
              
            
             </summary>
        </member>
        <member name="M:VectorR3ui.normalized(System.Double)">
             <summary>Convenience function that uses the vsc::normalize function to return the
            normalized vector  
            
             </summary>
        </member>
        <member name="M:VectorR3ui.normalized">
             <summary>Convenience function that uses the vsc::normalize function to return the
            normalized vector  
            
             </summary>
        </member>
        <member name="T:VectorR3uiList.VectorR3uiListEnumerator">
            Note that the IEnumerator documentation requires an InvalidOperationException to be thrown
            whenever the collection is modified. This has been done for changes in the size of the
            collection but not when one of the elements of the collection is modified as it is a bit
            tricky to detect unmanaged code that modifies the collection under our feet.
        </member>
        <member name="T:VectorR3us">
             <summary>The VectorR template class represents fixed-size, real vectors. The size of the
            vector and the element type are specified as part of the type, and are thus
            fixed at compile time. This vector class represents both positional vectors
            representing points, and covariance vectors such as normal and tangent vectors.  
            *N* is the number of elements, which must be greater than zero. *E* is the
            element type, typically <c>double</c>, <c>float</c>, or <c>int</c>.  
            
            Attributes
            ----------
            * `SIZE` : `const unsigned int`  
                The number of elements in vectors of this type.  
            
             </summary>
        </member>
        <member name="M:VectorR3us.#ctor(System.Collections.Generic.ICollection{System.UInt16})">
            <summary>Construct a VectorR3us from a collection of values.</summary>
            <remarks><code>values</code> must have size 3.</remarks>
            <exception cref="T:System.ArgumentException">If <code>values</code> is not size 3.</exception>
        </member>
        <member name="M:VectorR3us.#ctor(System.UInt16[])">
            <summary>Construct a VectorR3us from a collection of values.</summary>
            <remarks>3 parameters must be given.</remarks>
            <exception cref="T:System.ArgumentException">If exactly 3 parameters are not given.</exception>
        </member>
        <member name="M:VectorR3us.#ctor">
             <summary>Constructs a copy of *v*.  
            
             </summary>
        </member>
        <member name="M:VectorR3us.#ctor(System.UInt16)">
             <summary>Constructs a copy of *v*.  
            
             </summary>
        </member>
        <member name="M:VectorR3us.#ctor(SWIGTYPE_p_unsigned_short)">
             <summary>Constructs a copy of *v*.  
            
             </summary>
        </member>
        <member name="M:VectorR3us.#ctor(VectorR3us)">
             <summary>Constructs a copy of *v*.  
            
             </summary>
        </member>
        <member name="M:VectorR3us.set(System.UInt16)">
             <summary>Sets all elements of this vector to *element*.  
            
             </summary>
        </member>
        <member name="M:VectorR3us.setElements(SWIGTYPE_p_unsigned_short)">
             <summary>Copies the elements from *elementArray* to this vector. The array must contain
            *N* elements.  
            
             </summary>
        </member>
        <member name="M:VectorR3us.nonNegative">
             <summary>Returns true if every element of this vector is nonnegative.  
            
             </summary>
        </member>
        <member name="M:VectorR3us.positive">
             <summary>Returns true if every element of this vector is strictly positive.  
            
             </summary>
        </member>
        <member name="M:VectorR3us.size">
            <summary>
            </summary>
        </member>
        <member name="M:VectorR3us.xy">
             <summary>Similar to the OpenGL in shader function that returns the first 2 components of
            a vector. Components that are not defined are defaulted to zero.    note: In
            C++11 compilers, the return is optimized by copy ellision, so actual
                copies take place. See NRVO  
              
            
             </summary>
        </member>
        <member name="M:VectorR3us.xyz">
             <summary>Similar to the opengl in shader function that returns the first 3 components of
            a vector. Components that are not defined are defaulted to zero.    note: In
            C++11 compilers, the return is optimized by copy ellision, so actual
                copies take place. See NRVO  
              
            
             </summary>
        </member>
        <member name="M:VectorR3us.xyzw">
             <summary>Similar to the opengl in shader function that returns the first 3 components of
            a vector. Components that are not defined are defaulted to zero. An undefined W
            coordinate is defaulted to 1.    note: In C++11 compilers, the return is
            optimized by copy ellision, so actual
                copies take place. See NRVO  
              
            
             </summary>
        </member>
        <member name="M:VectorR3us.normalized(System.Double)">
             <summary>Convenience function that uses the vsc::normalize function to return the
            normalized vector  
            
             </summary>
        </member>
        <member name="M:VectorR3us.normalized">
             <summary>Convenience function that uses the vsc::normalize function to return the
            normalized vector  
            
             </summary>
        </member>
        <member name="T:VectorR3usList.VectorR3usListEnumerator">
            Note that the IEnumerator documentation requires an InvalidOperationException to be thrown
            whenever the collection is modified. This has been done for changes in the size of the
            collection but not when one of the elements of the collection is modified as it is a bit
            tricky to detect unmanaged code that modifies the collection under our feet.
        </member>
        <member name="T:VectorR4b">
             <summary>The VectorR template class represents fixed-size, real vectors. The size of the
            vector and the element type are specified as part of the type, and are thus
            fixed at compile time. This vector class represents both positional vectors
            representing points, and covariance vectors such as normal and tangent vectors.  
            *N* is the number of elements, which must be greater than zero. *E* is the
            element type, typically <c>double</c>, <c>float</c>, or <c>int</c>.  
            
            Attributes
            ----------
            * `SIZE` : `const unsigned int`  
                The number of elements in vectors of this type.  
            
             </summary>
        </member>
        <member name="M:VectorR4b.#ctor(System.Collections.Generic.ICollection{System.Char})">
            <summary>Construct a VectorR4b from a collection of values.</summary>
            <remarks><code>values</code> must have size 4.</remarks>
            <exception cref="T:System.ArgumentException">If <code>values</code> is not size 4.</exception>
        </member>
        <member name="M:VectorR4b.#ctor(System.Char[])">
            <summary>Construct a VectorR4b from a collection of values.</summary>
            <remarks>4 parameters must be given.</remarks>
            <exception cref="T:System.ArgumentException">If exactly 4 parameters are not given.</exception>
        </member>
        <member name="M:VectorR4b.#ctor">
             <summary>Constructs a copy of *v*.  
            
             </summary>
        </member>
        <member name="M:VectorR4b.#ctor(System.Char)">
             <summary>Constructs a copy of *v*.  
            
             </summary>
        </member>
        <member name="M:VectorR4b.#ctor(System.String)">
             <summary>Constructs a copy of *v*.  
            
             </summary>
        </member>
        <member name="M:VectorR4b.#ctor(VectorR4b)">
             <summary>Constructs a copy of *v*.  
            
             </summary>
        </member>
        <member name="M:VectorR4b.set(System.Char)">
             <summary>Sets all elements of this vector to *element*.  
            
             </summary>
        </member>
        <member name="M:VectorR4b.setElements(System.String)">
             <summary>Copies the elements from *elementArray* to this vector. The array must contain
            *N* elements.  
            
             </summary>
        </member>
        <member name="M:VectorR4b.nonNegative">
             <summary>Returns true if every element of this vector is nonnegative.  
            
             </summary>
        </member>
        <member name="M:VectorR4b.positive">
             <summary>Returns true if every element of this vector is strictly positive.  
            
             </summary>
        </member>
        <member name="M:VectorR4b.size">
            <summary>
            </summary>
        </member>
        <member name="M:VectorR4b.xy">
             <summary>Similar to the OpenGL in shader function that returns the first 2 components of
            a vector. Components that are not defined are defaulted to zero.    note: In
            C++11 compilers, the return is optimized by copy ellision, so actual
                copies take place. See NRVO  
              
            
             </summary>
        </member>
        <member name="M:VectorR4b.xyz">
             <summary>Similar to the opengl in shader function that returns the first 3 components of
            a vector. Components that are not defined are defaulted to zero.    note: In
            C++11 compilers, the return is optimized by copy ellision, so actual
                copies take place. See NRVO  
              
            
             </summary>
        </member>
        <member name="M:VectorR4b.xyzw">
             <summary>Similar to the opengl in shader function that returns the first 3 components of
            a vector. Components that are not defined are defaulted to zero. An undefined W
            coordinate is defaulted to 1.    note: In C++11 compilers, the return is
            optimized by copy ellision, so actual
                copies take place. See NRVO  
              
            
             </summary>
        </member>
        <member name="M:VectorR4b.normalized(System.Double)">
             <summary>Convenience function that uses the vsc::normalize function to return the
            normalized vector  
            
             </summary>
        </member>
        <member name="M:VectorR4b.normalized">
             <summary>Convenience function that uses the vsc::normalize function to return the
            normalized vector  
            
             </summary>
        </member>
        <member name="T:VectorR4bList.VectorR4bListEnumerator">
            Note that the IEnumerator documentation requires an InvalidOperationException to be thrown
            whenever the collection is modified. This has been done for changes in the size of the
            collection but not when one of the elements of the collection is modified as it is a bit
            tricky to detect unmanaged code that modifies the collection under our feet.
        </member>
        <member name="T:VectorR4d">
             <summary>The VectorR template class represents fixed-size, real vectors. The size of the
            vector and the element type are specified as part of the type, and are thus
            fixed at compile time. This vector class represents both positional vectors
            representing points, and covariance vectors such as normal and tangent vectors.  
            *N* is the number of elements, which must be greater than zero. *E* is the
            element type, typically <c>double</c>, <c>float</c>, or <c>int</c>.  
            
            Attributes
            ----------
            * `SIZE` : `const unsigned int`  
                The number of elements in vectors of this type.  
            
             </summary>
        </member>
        <member name="M:VectorR4d.#ctor(System.Collections.Generic.ICollection{System.Double})">
            <summary>Construct a VectorR4d from a collection of values.</summary>
            <remarks><code>values</code> must have size 4.</remarks>
            <exception cref="T:System.ArgumentException">If <code>values</code> is not size 4.</exception>
        </member>
        <member name="M:VectorR4d.#ctor(System.Double[])">
            <summary>Construct a VectorR4d from a collection of values.</summary>
            <remarks>4 parameters must be given.</remarks>
            <exception cref="T:System.ArgumentException">If exactly 4 parameters are not given.</exception>
        </member>
        <member name="M:VectorR4d.#ctor">
             <summary>Constructs a copy of *v*.  
            
             </summary>
        </member>
        <member name="M:VectorR4d.#ctor(System.Double)">
             <summary>Constructs a copy of *v*.  
            
             </summary>
        </member>
        <member name="M:VectorR4d.#ctor(SWIGTYPE_p_double)">
             <summary>Constructs a copy of *v*.  
            
             </summary>
        </member>
        <member name="M:VectorR4d.#ctor(VectorR4d)">
             <summary>Constructs a copy of *v*.  
            
             </summary>
        </member>
        <member name="M:VectorR4d.set(System.Double)">
             <summary>Sets all elements of this vector to *element*.  
            
             </summary>
        </member>
        <member name="M:VectorR4d.setElements(SWIGTYPE_p_double)">
             <summary>Copies the elements from *elementArray* to this vector. The array must contain
            *N* elements.  
            
             </summary>
        </member>
        <member name="M:VectorR4d.nonNegative">
             <summary>Returns true if every element of this vector is nonnegative.  
            
             </summary>
        </member>
        <member name="M:VectorR4d.positive">
             <summary>Returns true if every element of this vector is strictly positive.  
            
             </summary>
        </member>
        <member name="M:VectorR4d.size">
            <summary>
            </summary>
        </member>
        <member name="M:VectorR4d.xy">
             <summary>Similar to the OpenGL in shader function that returns the first 2 components of
            a vector. Components that are not defined are defaulted to zero.    note: In
            C++11 compilers, the return is optimized by copy ellision, so actual
                copies take place. See NRVO  
              
            
             </summary>
        </member>
        <member name="M:VectorR4d.xyz">
             <summary>Similar to the opengl in shader function that returns the first 3 components of
            a vector. Components that are not defined are defaulted to zero.    note: In
            C++11 compilers, the return is optimized by copy ellision, so actual
                copies take place. See NRVO  
              
            
             </summary>
        </member>
        <member name="M:VectorR4d.xyzw">
             <summary>Similar to the opengl in shader function that returns the first 3 components of
            a vector. Components that are not defined are defaulted to zero. An undefined W
            coordinate is defaulted to 1.    note: In C++11 compilers, the return is
            optimized by copy ellision, so actual
                copies take place. See NRVO  
              
            
             </summary>
        </member>
        <member name="M:VectorR4d.normalized(System.Double)">
             <summary>Convenience function that uses the vsc::normalize function to return the
            normalized vector  
            
             </summary>
        </member>
        <member name="M:VectorR4d.normalized">
             <summary>Convenience function that uses the vsc::normalize function to return the
            normalized vector  
            
             </summary>
        </member>
        <member name="T:VectorR4dList.VectorR4dListEnumerator">
            Note that the IEnumerator documentation requires an InvalidOperationException to be thrown
            whenever the collection is modified. This has been done for changes in the size of the
            collection but not when one of the elements of the collection is modified as it is a bit
            tricky to detect unmanaged code that modifies the collection under our feet.
        </member>
        <member name="T:VectorR4f">
             <summary>The VectorR template class represents fixed-size, real vectors. The size of the
            vector and the element type are specified as part of the type, and are thus
            fixed at compile time. This vector class represents both positional vectors
            representing points, and covariance vectors such as normal and tangent vectors.  
            *N* is the number of elements, which must be greater than zero. *E* is the
            element type, typically <c>double</c>, <c>float</c>, or <c>int</c>.  
            
            Attributes
            ----------
            * `SIZE` : `const unsigned int`  
                The number of elements in vectors of this type.  
            
             </summary>
        </member>
        <member name="M:VectorR4f.#ctor(System.Collections.Generic.ICollection{System.Single})">
            <summary>Construct a VectorR4f from a collection of values.</summary>
            <remarks><code>values</code> must have size 4.</remarks>
            <exception cref="T:System.ArgumentException">If <code>values</code> is not size 4.</exception>
        </member>
        <member name="M:VectorR4f.#ctor(System.Single[])">
            <summary>Construct a VectorR4f from a collection of values.</summary>
            <remarks>4 parameters must be given.</remarks>
            <exception cref="T:System.ArgumentException">If exactly 4 parameters are not given.</exception>
        </member>
        <member name="M:VectorR4f.#ctor">
             <summary>Constructs a copy of *v*.  
            
             </summary>
        </member>
        <member name="M:VectorR4f.#ctor(System.Single)">
             <summary>Constructs a copy of *v*.  
            
             </summary>
        </member>
        <member name="M:VectorR4f.#ctor(SWIGTYPE_p_float)">
             <summary>Constructs a copy of *v*.  
            
             </summary>
        </member>
        <member name="M:VectorR4f.#ctor(VectorR4f)">
             <summary>Constructs a copy of *v*.  
            
             </summary>
        </member>
        <member name="M:VectorR4f.set(System.Single)">
             <summary>Sets all elements of this vector to *element*.  
            
             </summary>
        </member>
        <member name="M:VectorR4f.setElements(SWIGTYPE_p_float)">
             <summary>Copies the elements from *elementArray* to this vector. The array must contain
            *N* elements.  
            
             </summary>
        </member>
        <member name="M:VectorR4f.nonNegative">
             <summary>Returns true if every element of this vector is nonnegative.  
            
             </summary>
        </member>
        <member name="M:VectorR4f.positive">
             <summary>Returns true if every element of this vector is strictly positive.  
            
             </summary>
        </member>
        <member name="M:VectorR4f.size">
            <summary>
            </summary>
        </member>
        <member name="M:VectorR4f.xy">
             <summary>Similar to the OpenGL in shader function that returns the first 2 components of
            a vector. Components that are not defined are defaulted to zero.    note: In
            C++11 compilers, the return is optimized by copy ellision, so actual
                copies take place. See NRVO  
              
            
             </summary>
        </member>
        <member name="M:VectorR4f.xyz">
             <summary>Similar to the opengl in shader function that returns the first 3 components of
            a vector. Components that are not defined are defaulted to zero.    note: In
            C++11 compilers, the return is optimized by copy ellision, so actual
                copies take place. See NRVO  
              
            
             </summary>
        </member>
        <member name="M:VectorR4f.xyzw">
             <summary>Similar to the opengl in shader function that returns the first 3 components of
            a vector. Components that are not defined are defaulted to zero. An undefined W
            coordinate is defaulted to 1.    note: In C++11 compilers, the return is
            optimized by copy ellision, so actual
                copies take place. See NRVO  
              
            
             </summary>
        </member>
        <member name="M:VectorR4f.normalized(System.Double)">
             <summary>Convenience function that uses the vsc::normalize function to return the
            normalized vector  
            
             </summary>
        </member>
        <member name="M:VectorR4f.normalized">
             <summary>Convenience function that uses the vsc::normalize function to return the
            normalized vector  
            
             </summary>
        </member>
        <member name="T:VectorR4fList.VectorR4fListEnumerator">
            Note that the IEnumerator documentation requires an InvalidOperationException to be thrown
            whenever the collection is modified. This has been done for changes in the size of the
            collection but not when one of the elements of the collection is modified as it is a bit
            tricky to detect unmanaged code that modifies the collection under our feet.
        </member>
        <member name="T:VectorR4i">
             <summary>The VectorR template class represents fixed-size, real vectors. The size of the
            vector and the element type are specified as part of the type, and are thus
            fixed at compile time. This vector class represents both positional vectors
            representing points, and covariance vectors such as normal and tangent vectors.  
            *N* is the number of elements, which must be greater than zero. *E* is the
            element type, typically <c>double</c>, <c>float</c>, or <c>int</c>.  
            
            Attributes
            ----------
            * `SIZE` : `const unsigned int`  
                The number of elements in vectors of this type.  
            
             </summary>
        </member>
        <member name="M:VectorR4i.#ctor(System.Collections.Generic.ICollection{System.Int32})">
            <summary>Construct a VectorR4i from a collection of values.</summary>
            <remarks><code>values</code> must have size 4.</remarks>
            <exception cref="T:System.ArgumentException">If <code>values</code> is not size 4.</exception>
        </member>
        <member name="M:VectorR4i.#ctor(System.Int32[])">
            <summary>Construct a VectorR4i from a collection of values.</summary>
            <remarks>4 parameters must be given.</remarks>
            <exception cref="T:System.ArgumentException">If exactly 4 parameters are not given.</exception>
        </member>
        <member name="M:VectorR4i.#ctor">
             <summary>Constructs a copy of *v*.  
            
             </summary>
        </member>
        <member name="M:VectorR4i.#ctor(System.Int32)">
             <summary>Constructs a copy of *v*.  
            
             </summary>
        </member>
        <member name="M:VectorR4i.#ctor(SWIGTYPE_p_int)">
             <summary>Constructs a copy of *v*.  
            
             </summary>
        </member>
        <member name="M:VectorR4i.#ctor(VectorR4i)">
             <summary>Constructs a copy of *v*.  
            
             </summary>
        </member>
        <member name="M:VectorR4i.set(System.Int32)">
             <summary>Sets all elements of this vector to *element*.  
            
             </summary>
        </member>
        <member name="M:VectorR4i.setElements(SWIGTYPE_p_int)">
             <summary>Copies the elements from *elementArray* to this vector. The array must contain
            *N* elements.  
            
             </summary>
        </member>
        <member name="M:VectorR4i.nonNegative">
             <summary>Returns true if every element of this vector is nonnegative.  
            
             </summary>
        </member>
        <member name="M:VectorR4i.positive">
             <summary>Returns true if every element of this vector is strictly positive.  
            
             </summary>
        </member>
        <member name="M:VectorR4i.size">
            <summary>
            </summary>
        </member>
        <member name="M:VectorR4i.xy">
             <summary>Similar to the OpenGL in shader function that returns the first 2 components of
            a vector. Components that are not defined are defaulted to zero.    note: In
            C++11 compilers, the return is optimized by copy ellision, so actual
                copies take place. See NRVO  
              
            
             </summary>
        </member>
        <member name="M:VectorR4i.xyz">
             <summary>Similar to the opengl in shader function that returns the first 3 components of
            a vector. Components that are not defined are defaulted to zero.    note: In
            C++11 compilers, the return is optimized by copy ellision, so actual
                copies take place. See NRVO  
              
            
             </summary>
        </member>
        <member name="M:VectorR4i.xyzw">
             <summary>Similar to the opengl in shader function that returns the first 3 components of
            a vector. Components that are not defined are defaulted to zero. An undefined W
            coordinate is defaulted to 1.    note: In C++11 compilers, the return is
            optimized by copy ellision, so actual
                copies take place. See NRVO  
              
            
             </summary>
        </member>
        <member name="M:VectorR4i.normalized(System.Double)">
             <summary>Convenience function that uses the vsc::normalize function to return the
            normalized vector  
            
             </summary>
        </member>
        <member name="M:VectorR4i.normalized">
             <summary>Convenience function that uses the vsc::normalize function to return the
            normalized vector  
            
             </summary>
        </member>
        <member name="T:VectorR4iList.VectorR4iListEnumerator">
            Note that the IEnumerator documentation requires an InvalidOperationException to be thrown
            whenever the collection is modified. This has been done for changes in the size of the
            collection but not when one of the elements of the collection is modified as it is a bit
            tricky to detect unmanaged code that modifies the collection under our feet.
        </member>
        <member name="T:VectorR4s">
             <summary>The VectorR template class represents fixed-size, real vectors. The size of the
            vector and the element type are specified as part of the type, and are thus
            fixed at compile time. This vector class represents both positional vectors
            representing points, and covariance vectors such as normal and tangent vectors.  
            *N* is the number of elements, which must be greater than zero. *E* is the
            element type, typically <c>double</c>, <c>float</c>, or <c>int</c>.  
            
            Attributes
            ----------
            * `SIZE` : `const unsigned int`  
                The number of elements in vectors of this type.  
            
             </summary>
        </member>
        <member name="M:VectorR4s.#ctor(System.Collections.Generic.ICollection{System.Int16})">
            <summary>Construct a VectorR4s from a collection of values.</summary>
            <remarks><code>values</code> must have size 4.</remarks>
            <exception cref="T:System.ArgumentException">If <code>values</code> is not size 4.</exception>
        </member>
        <member name="M:VectorR4s.#ctor(System.Int16[])">
            <summary>Construct a VectorR4s from a collection of values.</summary>
            <remarks>4 parameters must be given.</remarks>
            <exception cref="T:System.ArgumentException">If exactly 4 parameters are not given.</exception>
        </member>
        <member name="M:VectorR4s.#ctor">
             <summary>Constructs a copy of *v*.  
            
             </summary>
        </member>
        <member name="M:VectorR4s.#ctor(System.Int16)">
             <summary>Constructs a copy of *v*.  
            
             </summary>
        </member>
        <member name="M:VectorR4s.#ctor(SWIGTYPE_p_short)">
             <summary>Constructs a copy of *v*.  
            
             </summary>
        </member>
        <member name="M:VectorR4s.#ctor(VectorR4s)">
             <summary>Constructs a copy of *v*.  
            
             </summary>
        </member>
        <member name="M:VectorR4s.set(System.Int16)">
             <summary>Sets all elements of this vector to *element*.  
            
             </summary>
        </member>
        <member name="M:VectorR4s.setElements(SWIGTYPE_p_short)">
             <summary>Copies the elements from *elementArray* to this vector. The array must contain
            *N* elements.  
            
             </summary>
        </member>
        <member name="M:VectorR4s.nonNegative">
             <summary>Returns true if every element of this vector is nonnegative.  
            
             </summary>
        </member>
        <member name="M:VectorR4s.positive">
             <summary>Returns true if every element of this vector is strictly positive.  
            
             </summary>
        </member>
        <member name="M:VectorR4s.size">
            <summary>
            </summary>
        </member>
        <member name="M:VectorR4s.xy">
             <summary>Similar to the OpenGL in shader function that returns the first 2 components of
            a vector. Components that are not defined are defaulted to zero.    note: In
            C++11 compilers, the return is optimized by copy ellision, so actual
                copies take place. See NRVO  
              
            
             </summary>
        </member>
        <member name="M:VectorR4s.xyz">
             <summary>Similar to the opengl in shader function that returns the first 3 components of
            a vector. Components that are not defined are defaulted to zero.    note: In
            C++11 compilers, the return is optimized by copy ellision, so actual
                copies take place. See NRVO  
              
            
             </summary>
        </member>
        <member name="M:VectorR4s.xyzw">
             <summary>Similar to the opengl in shader function that returns the first 3 components of
            a vector. Components that are not defined are defaulted to zero. An undefined W
            coordinate is defaulted to 1.    note: In C++11 compilers, the return is
            optimized by copy ellision, so actual
                copies take place. See NRVO  
              
            
             </summary>
        </member>
        <member name="M:VectorR4s.normalized(System.Double)">
             <summary>Convenience function that uses the vsc::normalize function to return the
            normalized vector  
            
             </summary>
        </member>
        <member name="M:VectorR4s.normalized">
             <summary>Convenience function that uses the vsc::normalize function to return the
            normalized vector  
            
             </summary>
        </member>
        <member name="T:VectorR4sList.VectorR4sListEnumerator">
            Note that the IEnumerator documentation requires an InvalidOperationException to be thrown
            whenever the collection is modified. This has been done for changes in the size of the
            collection but not when one of the elements of the collection is modified as it is a bit
            tricky to detect unmanaged code that modifies the collection under our feet.
        </member>
        <member name="T:VectorR4ub">
             <summary>The VectorR template class represents fixed-size, real vectors. The size of the
            vector and the element type are specified as part of the type, and are thus
            fixed at compile time. This vector class represents both positional vectors
            representing points, and covariance vectors such as normal and tangent vectors.  
            *N* is the number of elements, which must be greater than zero. *E* is the
            element type, typically <c>double</c>, <c>float</c>, or <c>int</c>.  
            
            Attributes
            ----------
            * `SIZE` : `const unsigned int`  
                The number of elements in vectors of this type.  
            
             </summary>
        </member>
        <member name="M:VectorR4ub.#ctor(System.Collections.Generic.ICollection{System.Byte})">
            <summary>Construct a VectorR4ub from a collection of values.</summary>
            <remarks><code>values</code> must have size 4.</remarks>
            <exception cref="T:System.ArgumentException">If <code>values</code> is not size 4.</exception>
        </member>
        <member name="M:VectorR4ub.#ctor(System.Byte[])">
            <summary>Construct a VectorR4ub from a collection of values.</summary>
            <remarks>4 parameters must be given.</remarks>
            <exception cref="T:System.ArgumentException">If exactly 4 parameters are not given.</exception>
        </member>
        <member name="M:VectorR4ub.#ctor">
             <summary>Constructs a copy of *v*.  
            
             </summary>
        </member>
        <member name="M:VectorR4ub.#ctor(System.Byte)">
             <summary>Constructs a copy of *v*.  
            
             </summary>
        </member>
        <member name="M:VectorR4ub.#ctor(SWIGTYPE_p_unsigned_char)">
             <summary>Constructs a copy of *v*.  
            
             </summary>
        </member>
        <member name="M:VectorR4ub.#ctor(VectorR4ub)">
             <summary>Constructs a copy of *v*.  
            
             </summary>
        </member>
        <member name="M:VectorR4ub.set(System.Byte)">
             <summary>Sets all elements of this vector to *element*.  
            
             </summary>
        </member>
        <member name="M:VectorR4ub.setElements(SWIGTYPE_p_unsigned_char)">
             <summary>Copies the elements from *elementArray* to this vector. The array must contain
            *N* elements.  
            
             </summary>
        </member>
        <member name="M:VectorR4ub.nonNegative">
             <summary>Returns true if every element of this vector is nonnegative.  
            
             </summary>
        </member>
        <member name="M:VectorR4ub.positive">
             <summary>Returns true if every element of this vector is strictly positive.  
            
             </summary>
        </member>
        <member name="M:VectorR4ub.size">
            <summary>
            </summary>
        </member>
        <member name="M:VectorR4ub.xy">
             <summary>Similar to the OpenGL in shader function that returns the first 2 components of
            a vector. Components that are not defined are defaulted to zero.    note: In
            C++11 compilers, the return is optimized by copy ellision, so actual
                copies take place. See NRVO  
              
            
             </summary>
        </member>
        <member name="M:VectorR4ub.xyz">
             <summary>Similar to the opengl in shader function that returns the first 3 components of
            a vector. Components that are not defined are defaulted to zero.    note: In
            C++11 compilers, the return is optimized by copy ellision, so actual
                copies take place. See NRVO  
              
            
             </summary>
        </member>
        <member name="M:VectorR4ub.xyzw">
             <summary>Similar to the opengl in shader function that returns the first 3 components of
            a vector. Components that are not defined are defaulted to zero. An undefined W
            coordinate is defaulted to 1.    note: In C++11 compilers, the return is
            optimized by copy ellision, so actual
                copies take place. See NRVO  
              
            
             </summary>
        </member>
        <member name="M:VectorR4ub.normalized(System.Double)">
             <summary>Convenience function that uses the vsc::normalize function to return the
            normalized vector  
            
             </summary>
        </member>
        <member name="M:VectorR4ub.normalized">
             <summary>Convenience function that uses the vsc::normalize function to return the
            normalized vector  
            
             </summary>
        </member>
        <member name="T:VectorR4ubList.VectorR4ubListEnumerator">
            Note that the IEnumerator documentation requires an InvalidOperationException to be thrown
            whenever the collection is modified. This has been done for changes in the size of the
            collection but not when one of the elements of the collection is modified as it is a bit
            tricky to detect unmanaged code that modifies the collection under our feet.
        </member>
        <member name="T:VectorR4ui">
             <summary>The VectorR template class represents fixed-size, real vectors. The size of the
            vector and the element type are specified as part of the type, and are thus
            fixed at compile time. This vector class represents both positional vectors
            representing points, and covariance vectors such as normal and tangent vectors.  
            *N* is the number of elements, which must be greater than zero. *E* is the
            element type, typically <c>double</c>, <c>float</c>, or <c>int</c>.  
            
            Attributes
            ----------
            * `SIZE` : `const unsigned int`  
                The number of elements in vectors of this type.  
            
             </summary>
        </member>
        <member name="M:VectorR4ui.#ctor(System.Collections.Generic.ICollection{System.UInt32})">
            <summary>Construct a VectorR4ui from a collection of values.</summary>
            <remarks><code>values</code> must have size 4.</remarks>
            <exception cref="T:System.ArgumentException">If <code>values</code> is not size 4.</exception>
        </member>
        <member name="M:VectorR4ui.#ctor(System.UInt32[])">
            <summary>Construct a VectorR4ui from a collection of values.</summary>
            <remarks>4 parameters must be given.</remarks>
            <exception cref="T:System.ArgumentException">If exactly 4 parameters are not given.</exception>
        </member>
        <member name="M:VectorR4ui.#ctor">
             <summary>Constructs a copy of *v*.  
            
             </summary>
        </member>
        <member name="M:VectorR4ui.#ctor(System.UInt32)">
             <summary>Constructs a copy of *v*.  
            
             </summary>
        </member>
        <member name="M:VectorR4ui.#ctor(SWIGTYPE_p_unsigned_int)">
             <summary>Constructs a copy of *v*.  
            
             </summary>
        </member>
        <member name="M:VectorR4ui.#ctor(VectorR4ui)">
             <summary>Constructs a copy of *v*.  
            
             </summary>
        </member>
        <member name="M:VectorR4ui.set(System.UInt32)">
             <summary>Sets all elements of this vector to *element*.  
            
             </summary>
        </member>
        <member name="M:VectorR4ui.setElements(SWIGTYPE_p_unsigned_int)">
             <summary>Copies the elements from *elementArray* to this vector. The array must contain
            *N* elements.  
            
             </summary>
        </member>
        <member name="M:VectorR4ui.nonNegative">
             <summary>Returns true if every element of this vector is nonnegative.  
            
             </summary>
        </member>
        <member name="M:VectorR4ui.positive">
             <summary>Returns true if every element of this vector is strictly positive.  
            
             </summary>
        </member>
        <member name="M:VectorR4ui.size">
            <summary>
            </summary>
        </member>
        <member name="M:VectorR4ui.xy">
             <summary>Similar to the OpenGL in shader function that returns the first 2 components of
            a vector. Components that are not defined are defaulted to zero.    note: In
            C++11 compilers, the return is optimized by copy ellision, so actual
                copies take place. See NRVO  
              
            
             </summary>
        </member>
        <member name="M:VectorR4ui.xyz">
             <summary>Similar to the opengl in shader function that returns the first 3 components of
            a vector. Components that are not defined are defaulted to zero.    note: In
            C++11 compilers, the return is optimized by copy ellision, so actual
                copies take place. See NRVO  
              
            
             </summary>
        </member>
        <member name="M:VectorR4ui.xyzw">
             <summary>Similar to the opengl in shader function that returns the first 3 components of
            a vector. Components that are not defined are defaulted to zero. An undefined W
            coordinate is defaulted to 1.    note: In C++11 compilers, the return is
            optimized by copy ellision, so actual
                copies take place. See NRVO  
              
            
             </summary>
        </member>
        <member name="M:VectorR4ui.normalized(System.Double)">
             <summary>Convenience function that uses the vsc::normalize function to return the
            normalized vector  
            
             </summary>
        </member>
        <member name="M:VectorR4ui.normalized">
             <summary>Convenience function that uses the vsc::normalize function to return the
            normalized vector  
            
             </summary>
        </member>
        <member name="T:VectorR4uiList.VectorR4uiListEnumerator">
            Note that the IEnumerator documentation requires an InvalidOperationException to be thrown
            whenever the collection is modified. This has been done for changes in the size of the
            collection but not when one of the elements of the collection is modified as it is a bit
            tricky to detect unmanaged code that modifies the collection under our feet.
        </member>
        <member name="T:VectorR4us">
             <summary>The VectorR template class represents fixed-size, real vectors. The size of the
            vector and the element type are specified as part of the type, and are thus
            fixed at compile time. This vector class represents both positional vectors
            representing points, and covariance vectors such as normal and tangent vectors.  
            *N* is the number of elements, which must be greater than zero. *E* is the
            element type, typically <c>double</c>, <c>float</c>, or <c>int</c>.  
            
            Attributes
            ----------
            * `SIZE` : `const unsigned int`  
                The number of elements in vectors of this type.  
            
             </summary>
        </member>
        <member name="M:VectorR4us.#ctor(System.Collections.Generic.ICollection{System.UInt16})">
            <summary>Construct a VectorR4us from a collection of values.</summary>
            <remarks><code>values</code> must have size 4.</remarks>
            <exception cref="T:System.ArgumentException">If <code>values</code> is not size 4.</exception>
        </member>
        <member name="M:VectorR4us.#ctor(System.UInt16[])">
            <summary>Construct a VectorR4us from a collection of values.</summary>
            <remarks>4 parameters must be given.</remarks>
            <exception cref="T:System.ArgumentException">If exactly 4 parameters are not given.</exception>
        </member>
        <member name="M:VectorR4us.#ctor">
             <summary>Constructs a copy of *v*.  
            
             </summary>
        </member>
        <member name="M:VectorR4us.#ctor(System.UInt16)">
             <summary>Constructs a copy of *v*.  
            
             </summary>
        </member>
        <member name="M:VectorR4us.#ctor(SWIGTYPE_p_unsigned_short)">
             <summary>Constructs a copy of *v*.  
            
             </summary>
        </member>
        <member name="M:VectorR4us.#ctor(VectorR4us)">
             <summary>Constructs a copy of *v*.  
            
             </summary>
        </member>
        <member name="M:VectorR4us.set(System.UInt16)">
             <summary>Sets all elements of this vector to *element*.  
            
             </summary>
        </member>
        <member name="M:VectorR4us.setElements(SWIGTYPE_p_unsigned_short)">
             <summary>Copies the elements from *elementArray* to this vector. The array must contain
            *N* elements.  
            
             </summary>
        </member>
        <member name="M:VectorR4us.nonNegative">
             <summary>Returns true if every element of this vector is nonnegative.  
            
             </summary>
        </member>
        <member name="M:VectorR4us.positive">
             <summary>Returns true if every element of this vector is strictly positive.  
            
             </summary>
        </member>
        <member name="M:VectorR4us.size">
            <summary>
            </summary>
        </member>
        <member name="M:VectorR4us.xy">
             <summary>Similar to the OpenGL in shader function that returns the first 2 components of
            a vector. Components that are not defined are defaulted to zero.    note: In
            C++11 compilers, the return is optimized by copy ellision, so actual
                copies take place. See NRVO  
              
            
             </summary>
        </member>
        <member name="M:VectorR4us.xyz">
             <summary>Similar to the opengl in shader function that returns the first 3 components of
            a vector. Components that are not defined are defaulted to zero.    note: In
            C++11 compilers, the return is optimized by copy ellision, so actual
                copies take place. See NRVO  
              
            
             </summary>
        </member>
        <member name="M:VectorR4us.xyzw">
             <summary>Similar to the opengl in shader function that returns the first 3 components of
            a vector. Components that are not defined are defaulted to zero. An undefined W
            coordinate is defaulted to 1.    note: In C++11 compilers, the return is
            optimized by copy ellision, so actual
                copies take place. See NRVO  
              
            
             </summary>
        </member>
        <member name="M:VectorR4us.normalized(System.Double)">
             <summary>Convenience function that uses the vsc::normalize function to return the
            normalized vector  
            
             </summary>
        </member>
        <member name="M:VectorR4us.normalized">
             <summary>Convenience function that uses the vsc::normalize function to return the
            normalized vector  
            
             </summary>
        </member>
        <member name="T:VectorR4usList.VectorR4usListEnumerator">
            Note that the IEnumerator documentation requires an InvalidOperationException to be thrown
            whenever the collection is modified. This has been done for changes in the size of the
            collection but not when one of the elements of the collection is modified as it is a bit
            tricky to detect unmanaged code that modifies the collection under our feet.
        </member>
        <member name="T:VelocityEngine">
             <summary>Common operations driving the Velocity platform core.  
            
             </summary>
        </member>
        <member name="M:VelocityEngine.#ctor">
            <summary>
            </summary>
        </member>
        <member name="M:VelocityEngine.loginToWorkstation(System.String,System.String,System.String,System.Boolean)">
             <summary>Connect to a workstation database given the path to the database folder and the
            database name.  
              
            
             </summary>
            
             <param name="username">
            the user to login with  
            
            </param>
            
            
             <param name="password">
            the password  
            
            </param>
            
            
             <param name="path">
            the database folder (not the .dat file)  
            
            </param>
            
            
             <param name="force">
            if we should kick out a currently logged in user  
            
            </param>
        </member>
        <member name="M:VelocityEngine.loginToWorkstation(System.String,System.String,System.String)">
             <summary>Connect to a workstation database given the path to the database folder and the
            database name.  
              
            
             </summary>
            
             <param name="username">
            the user to login with  
            
            </param>
            
            
             <param name="password">
            the password  
            
            </param>
            
            
             <param name="path">
            the database folder (not the .dat file)  
            
            </param>
            
            
             <param name="force">
            if we should kick out a currently logged in user  
            
            </param>
        </member>
        <member name="M:VelocityEngine.loginToGrid(System.String,System.String,System.String,System.Int32,System.String)">
             <summary>Connects to a Grid database server and logs in to a particular database.  
            
             </summary>
        </member>
        <member name="M:VelocityEngine.logout">
             <summary>Logout of the current database, if any. Note that after logout, all Operations
            class instances returned by this engine become invalid and should not be used.  
            
             </summary>
        </member>
        <member name="M:VelocityEngine.isLoggedIn">
             <summary>Returns whether this engine is currently logged in.  
            
             </summary>
        </member>
        <member name="M:VelocityEngine.getCurrentPatient">
             <summary>Returns the current patient, if one is loaded.    If no patient is loaded, the
            returned object will have a velocity id of -1 and the engine's error message
            will be set.  
            
             </summary>
        </member>
        <member name="M:VelocityEngine.deletePatient(System.String,System.Boolean)">
             <summary>Deletes a patient identified by <c>patientId</c>. if the patientId is not unique
            and the force flag is false the function will not delete the patient and return
            false. if the force flag is true, the function will delete all patients with
            given patient id and return true.  
            
             </summary>
        </member>
        <member name="M:VelocityEngine.loadPatientByPatientId(System.String)">
             <summary>Loads a patient identified by <c>patientId</c>.  
            
             </summary>
            
             <param name="patientId">
            is the DICOM patient id  
            
            </param>
            <returns>
            if the patient was successfully loaded  
            
            </returns>
        </member>
        <member name="M:VelocityEngine.loadPatient(System.Int32)">
             <summary>Loads a patient by its internal database id.  
            
             </summary>
            
             <param name="patientId">
            is the internal velocity database id  
            
            </param>
            <returns>
            if the patient was successfully loaded  
            
            </returns>
        </member>
        <member name="M:VelocityEngine.unloadPatient">
             <summary>Unloads the currently set patient, if any. This also causes the primary and
            secondary volumes to be unloaded if set.  
            
             </summary>
        </member>
        <member name="M:VelocityEngine.loadPrimaryVolumeByUID(System.String)">
             <summary>Loads the primary volume given by <c>volumeUID</c>.  
            
             </summary><returns>
            if the volume was successfully loaded  
            
            </returns>
        </member>
        <member name="M:VelocityEngine.unloadPrimaryVolume">
             <summary>Unloads the primary volume, if any. This also causes the secondary to be
            unloaded if present.  
            
             </summary>
        </member>
        <member name="M:VelocityEngine.getPrimaryVolume">
             <summary>Returns the current primary volume, if loaded. If not loaded, returns an invalid
            Volume.  
            
             </summary>
        </member>
        <member name="M:VelocityEngine.loadSecondaryVolumeByUID(System.String)">
             <summary>Loads the secondary volume given by <c>volumeUID</c>.  
            
             </summary><returns>
            if the volume was successfully loaded  
            
            </returns>
        </member>
        <member name="M:VelocityEngine.unloadSecondaryVolume">
             <summary>Unloads the secondary volume, if any.  
            
             </summary>
        </member>
        <member name="M:VelocityEngine.getSecondaryVolume">
             <summary>Returns the current secondary volume, if loaded. If not loaded, returns an
            invalid volume.  
            
             </summary>
        </member>
        <member name="M:VelocityEngine.loadStructure(System.Int32)">
             <summary>Loads a structure by id. The structure must be associated with the current
            primary or secondary volumes.  
              
            
             </summary><returns>
            the structure handle, if loaded, or an invalid handle on error  
            
            </returns>
        </member>
        <member name="M:VelocityEngine.loadStructureByName(System.String,System.String)">
             <summary>Loads a structure given by <c>name</c>.  
            Currently the name must be unique in the structure set and the structure must be
            associated with the currently loaded primary volume or this method will return
            an error.  
              
            
             </summary><returns>
            if the structure was successfully loaded  
            
            </returns>
        </member>
        <member name="M:VelocityEngine.loadStructureByUID(System.String)">
             <summary>Loads a structure given by its UID.  
            
             </summary><returns>
            the structure handle, if loaded, or an invalid handle on error  
            
            </returns>
        </member>
        <member name="M:VelocityEngine.loadRegistrationByName(System.String)">
             <summary>Loads a registration by name. If the volumes are in the same FOR and the name is
            "DICOM" but the registration does not exist, it will create a DICOM
            registration and load it the first time the volumes are loaded. The registration
            must be between the currently loaded primary and secondary volumes and the name
            must be unique or this function will return an error.  
            
             </summary>
        </member>
        <member name="M:VelocityEngine.loadRegistration(System.Int32)">
             <summary>Loads a registration by its internal database id.  
            
             </summary><returns>
            the loaded registration or an invalid one on error  
            
            </returns>
        </member>
        <member name="M:VelocityEngine.loadPlan(System.Int32)">
             <summary>Loads a plan by its internal id. Automatically loads the primary and secondary
            volumes linked to the plan.  
            
             </summary><returns>
            the plan that was loaded or an invalid plan on error  
            
            </returns>
        </member>
        <member name="M:VelocityEngine.loadPlanByUID(System.String)">
             <summary>Loads a plan given by its UID. Automatically loads primary and secondary volume
            linked to the plan.  
            
             </summary><returns>
            the plan that was loaded or an invalid plan on error  
            
            </returns>
        </member>
        <member name="M:VelocityEngine.getValueAtStructureCenter(VelocityEngine.ValueMode,System.Boolean)">
             <summary>Returns the value on the primary/secondary volume at structure center given by
            its uid. Assumes linear interpolation by default, otherwise uses nearestNeighbor
            If the structure is not set/loaded, this function will return -1.  
            
             </summary>
        </member>
        <member name="M:VelocityEngine.getValueAtStructureCenter(VelocityEngine.ValueMode)">
             <summary>Returns the value on the primary/secondary volume at structure center given by
            its uid. Assumes linear interpolation by default, otherwise uses nearestNeighbor
            If the structure is not set/loaded, this function will return -1.  
            
             </summary>
        </member>
        <member name="M:VelocityEngine.getPatientVolumeUIDs(System.String)">
             <summary>Returns a vector of all volumeUIDs for the given patientID and modality  
            
             </summary>
        </member>
        <member name="M:VelocityEngine.getPatientVolumeUIDs(System.String,System.String)">
             <summary>Returns a vector of all volumeUIDs for the given patientID and modality  
            
             </summary>
        </member>
        <member name="M:VelocityEngine.getVolumeOperations">
             <summary>Returns the volume operations for this engine.  
            The engine must be connected to a database or this returns a null pointer. The
            volume operations are owned by this engine and should not be kept across
            dis/reconnects or destruction of this engine.  
            
             </summary>
        </member>
        <member name="M:VelocityEngine.getRegistrationOperations">
             <summary>Returns the registration operations for this engine.  
            The engine must be connected to a database or this returns a null pointer. The
            registration operations are owned by this engine and should not be kept across
            dis/reconnects or destruction of this engine.  
            
             </summary>
        </member>
        <member name="M:VelocityEngine.getReportOperations">
             <summary>Returns the report operations for this engine.  
            The engine must be connected to a database or this returns a null pointer. The
            report operations are owned by this engine and should not be kept across
            dis/reconnects or destruction of this engine.  
            
             </summary>
        </member>
        <member name="M:VelocityEngine.getImportOperations">
             <summary>Returns the import operations for this engine.  
            The engine must be connected to a database or this returns a null pointer. The
            import operations are owned by this engine and should not be kept across
            dis/reconnects or destruction of this engine.  
            
             </summary>
        </member>
        <member name="M:VelocityEngine.getExportOperations">
             <summary>Returns the export operations for this engine.  
            The engine must be connected to a database or this returns a null pointer. The
            export operations are owned by this engine and should not be kept across
            dis/reconnects or destruction of this engine.  
            
             </summary>
        </member>
        <member name="M:VelocityEngine.getStructureOperations">
             <summary>Returns the structure operations for this engine.  
            The engine must be connected to a database or this returns a null pointer. The
            export operations are owned by this engine and should not be kept across
            dis/reconnects or destruction of this engine.  
            
             </summary>
        </member>
        <member name="M:VelocityEngine.getPatientDataOperations">
             <summary>Returns operations for inspecting patient data for this engine.  
            The engine must be connected to a database or this returns a null pointer. The
            patient data operations are owned by this engine and should not be kept across
            dis/reconnects or destruction of this engine.  
            
             </summary>
        </member>
        <member name="M:VelocityEngine.getErrorMessage">
             <summary>Returns the error message of the last operation, or the empty string in case of
            no error. This message is always in English. It is UTF-8 encoded.  
            
             </summary>
        </member>
        <member name="M:VelocityEngine.getLocalizedErrorMessage">
             <summary>Returns the error message of the last operation, or the empty string in case of
            no error. This message may be translated to a non-English language. It is UTF-8
            encoded.  
            
             </summary>
        </member>
        <member name="T:Volume">
             <summary>Volume metadata.  
            
             </summary>
        </member>
        <member name="M:Volume.isLocked">
            <summary>
            </summary>
        </member>
        <member name="M:Volume.getCreateDate">
             <summary>Returns the record creation date in ISO format.  
            
             </summary>
        </member>
        <member name="M:Volume.getEditDate">
             <summary>Returns the record edit date in ISO format.  
            
             </summary>
        </member>
        <member name="M:Volume.getPatient">
            <summary>
            </summary>
        </member>
        <member name="M:Volume.getName">
            <summary>
            </summary>
        </member>
        <member name="M:Volume.getModality">
            <summary>
            </summary>
        </member>
        <member name="M:Volume.getVolumeUID">
            <summary>
            </summary>
        </member>
        <member name="M:Volume.getFrameOfReferenceUID">
            <summary>
            </summary>
        </member>
        <member name="M:Volume.getSeriesUID">
            <summary>
            </summary>
        </member>
        <member name="M:Volume.getDicomPatientId">
            <summary>
            </summary>
        </member>
        <member name="M:Volume.getDicomPatientName">
            <summary>
            </summary>
        </member>
        <member name="M:Volume.getDicomPatientSex">
            <summary>
            </summary>
        </member>
        <member name="M:Volume.getDicomPatientDateOfBirth">
            <summary>
            </summary>
        </member>
        <member name="M:Volume.getSourceType">
            <summary>
            </summary>
        </member>
        <member name="M:Volume.getSeriesNumber">
            <summary>
            </summary>
        </member>
        <member name="M:Volume.getSeriesDate">
            <summary>
            </summary>
        </member>
        <member name="M:Volume.getSeriesTime">
            <summary>
            </summary>
        </member>
        <member name="M:Volume.getSeriesType">
            <summary>
            </summary>
        </member>
        <member name="M:Volume.getStudyDate">
            <summary>
            </summary>
        </member>
        <member name="M:Volume.getStudyTime">
            <summary>
            </summary>
        </member>
        <member name="M:Volume.getAccessionNumber">
            <summary>
            </summary>
        </member>
        <member name="M:Volume.getStudyId">
            <summary>
            </summary>
        </member>
        <member name="M:Volume.getStudyInstanceUID">
            <summary>
            </summary>
        </member>
        <member name="M:Volume.getStudyDescription">
            <summary>
            </summary>
        </member>
        <member name="M:Volume.getDicomReferringPhysicianName">
            <summary>
            </summary>
        </member>
        <member name="M:Volume.getPlanUID">
             <summary>Returns the plan UID for dose volumes.  
            
             </summary>
        </member>
        <member name="M:Volume.getLinkedPlans">
            <summary>
            </summary>
        </member>
        <member name="M:Volume.getLinkedRegistrations">
            <summary>
            </summary>
        </member>
        <member name="M:Volume.getStructureSets">
            <summary>
            </summary>
        </member>
        <member name="M:Volume.getAllStructures">
            <summary>
            </summary>
        </member>
        <member name="M:Volume.registrationCommissioningMarkerLists(System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:Volume.registrationCommissioningMarkerLists">
            <summary>
            </summary>
        </member>
        <member name="T:VolumeList.VolumeListEnumerator">
            Note that the IEnumerator documentation requires an InvalidOperationException to be thrown
            whenever the collection is modified. This has been done for changes in the size of the
            collection but not when one of the elements of the collection is modified as it is a bit
            tricky to detect unmanaged code that modifies the collection under our feet.
        </member>
        <member name="T:VolumeOperations">
            <summary>
            </summary>
        </member>
        <member name="M:VolumeOperations.#ctor(SWIGTYPE_p_vsc__Persistor,SWIGTYPE_p_vsc__Database)">
            <summary>
            </summary>
        </member>
        <member name="M:VolumeOperations.createResampledVolume(VolumeResampleOperation,System.String,System.Double)">
             <summary>Carries out the resampling operation *elementOperation* against the current
            primary volume and secondary volumes.  
              
            
             </summary><returns>
            the newly created volume id or <c>-1</c> on error  
            
            </returns>
        </member>
        <member name="M:VolumeOperations.createResampledVolume(VolumeResampleOperation,System.String)">
             <summary>Carries out the resampling operation *elementOperation* against the current
            primary volume and secondary volumes.  
              
            
             </summary><returns>
            the newly created volume id or <c>-1</c> on error  
            
            </returns>
        </member>
        <member name="M:VolumeOperations.createResampledVolume(VolumeResampleOperation)">
             <summary>Carries out the resampling operation *elementOperation* against the current
            primary volume and secondary volumes.  
              
            
             </summary><returns>
            the newly created volume id or <c>-1</c> on error  
            
            </returns>
        </member>
        <member name="M:VolumeOperations.createResampledPrimaryVolume(VolumeResampleOperation,System.String,System.Double)">
             <summary>Carries out the resampling operation *elementOperation* for the current primary
            volume only. Only operations that operate on a single volume should be passed,
            e.g. VolumeResampleScale or VolumeResampleFadeCorrection.  
              
            
             </summary>
            
             <param name="elementOperation">
            the resampling operation  
            
            </param>
            
            
             <param name="name">
            an optional name override  
            
            </param>
            
            
             <param name="scalingCoefficient">
            scale factor if scaling  
            
            </param>
            <returns>
            the newly created volume id or <c>-1</c> on error  
            
            </returns>
        </member>
        <member name="M:VolumeOperations.createResampledPrimaryVolume(VolumeResampleOperation,System.String)">
             <summary>Carries out the resampling operation *elementOperation* for the current primary
            volume only. Only operations that operate on a single volume should be passed,
            e.g. VolumeResampleScale or VolumeResampleFadeCorrection.  
              
            
             </summary>
            
             <param name="elementOperation">
            the resampling operation  
            
            </param>
            
            
             <param name="name">
            an optional name override  
            
            </param>
            
            
             <param name="scalingCoefficient">
            scale factor if scaling  
            
            </param>
            <returns>
            the newly created volume id or <c>-1</c> on error  
            
            </returns>
        </member>
        <member name="M:VolumeOperations.createResampledPrimaryVolume(VolumeResampleOperation)">
             <summary>Carries out the resampling operation *elementOperation* for the current primary
            volume only. Only operations that operate on a single volume should be passed,
            e.g. VolumeResampleScale or VolumeResampleFadeCorrection.  
              
            
             </summary>
            
             <param name="elementOperation">
            the resampling operation  
            
            </param>
            
            
             <param name="name">
            an optional name override  
            
            </param>
            
            
             <param name="scalingCoefficient">
            scale factor if scaling  
            
            </param>
            <returns>
            the newly created volume id or <c>-1</c> on error  
            
            </returns>
        </member>
        <member name="M:VolumeOperations.createBEDose(System.Double,StringList,IntList,DoubleList,SWIGTYPE_p_vsc__ProgressReporter)">
             <summary>Carries out the BED scaling operation for the current secondary volume against
            the current primary volume.  
            Pass in the vector of structure names, structure Ids, structure ratios in the
            same order.  
            Note,the currently loaded secondary must be a (PHYSICAL) dose volume or an error
            is returned.  
              
            
             </summary><returns>
            the newly created volume id or <c>-1</c> on error  
            
            </returns>
        </member>
        <member name="M:VolumeOperations.createBEDose(System.Double,StringList,IntList,DoubleList)">
             <summary>Carries out the BED scaling operation for the current secondary volume against
            the current primary volume.  
            Pass in the vector of structure names, structure Ids, structure ratios in the
            same order.  
            Note,the currently loaded secondary must be a (PHYSICAL) dose volume or an error
            is returned.  
              
            
             </summary><returns>
            the newly created volume id or <c>-1</c> on error  
            
            </returns>
        </member>
        <member name="M:VolumeOperations.createBEDoseByStructureUIDs(System.Double,StringList,StringList,DoubleList,SWIGTYPE_p_vsc__ProgressReporter)">
             <summary>Carries out the BED scaling operation for the current secondary volume against
            the current primary volume.  
            Pass in the vector of structure names, structure Ids, structure ratios in the
            same order.  
            Note,the currently loaded secondary must be a (PHYSICAL) dose volume or an error
            is returned.  
              
            
             </summary><returns>
            the newly created volume id or <c>-1</c> on error  
            
            </returns>
        </member>
        <member name="M:VolumeOperations.createBEDoseByStructureUIDs(System.Double,StringList,StringList,DoubleList)">
             <summary>Carries out the BED scaling operation for the current secondary volume against
            the current primary volume.  
            Pass in the vector of structure names, structure Ids, structure ratios in the
            same order.  
            Note,the currently loaded secondary must be a (PHYSICAL) dose volume or an error
            is returned.  
              
            
             </summary><returns>
            the newly created volume id or <c>-1</c> on error  
            
            </returns>
        </member>
        <member name="M:VolumeOperations.getVolumetricData(System.Int32)">
             <summary>Retrieves volume data in volumetric form.  
            The volumeId must loaded as primary volume. On error, the data member of the
            volume data will be empty.  
            
             </summary>
        </member>
        <member name="M:VolumeOperations.getErrorMessage">
            <summary>
            </summary>
        </member>
        <member name="M:VolumeOperations.getLocalizedErrorMessage">
            <summary>
            </summary>
        </member>
    </members>
</doc>
